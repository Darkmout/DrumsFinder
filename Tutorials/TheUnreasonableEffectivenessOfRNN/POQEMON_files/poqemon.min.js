angular.module("apriori", [ "ui.bootstrap" ]);

angular.module("neighbors", [ "ui.bootstrap", "utils" ]);

angular.module("home", []);

angular.module("neighbors", [ "ui.bootstrap", "utils" ]);

angular.module("graphs", [ "utils" ]);

angular.module("language", []);

angular.module("utils", []);

angular.module("Presentation", [ "graphs", "ngSanitize", "home", "smoothScroll", "utils" ]);

angular.module("PoqemonApp", [ "home", "neighbors", "utils", "graphs", "language", "ngRoute" ]).config([ "$routeProvider", "$compileProvider", function($routeProvider, $compileProvider) {
    $routeProvider.when("/", {
        template: '<div ng-controller="MainController"> <ng-include src="\'nav.html\'"> </ng-include> <ng-include src="\'app/components/home/homeTemplate.html\'" > </ng-include>  </div>',
        controller: [ "$scope", function($scope) {
            $scope.globalView = {
                type: "globe"
            };
            var date = new Date();
            date.setDate(date.getDate() - 90);
            $scope.initialValues = {
                time: {
                    minValue: date
                }
            };
        } ],
        activetab: "/"
    }).when("/map", {
        template: '<div ng-controller="MainController"> <ng-include src="\'nav.html\'"> </ng-include> <ng-include src="\'app/components/home/homeTemplate.html\'" > </ng-include>  </div>',
        controller: [ "$scope", function($scope) {
            $scope.globalView = {
                type: "map"
            };
            var date = new Date();
            date.setDate(date.getDate() - 90);
            $scope.initialValues = {
                time: {
                    minValue: date
                }
            };
        } ],
        activetab: "map"
    }).when("/neighbors", {
        template: '<div ng-controller="MainController"> <ng-include src="\'nav.html\'" > </ng-include>   <ng-include src="\'app/components/neighbors/neighborsTemplate.html\'" > </ng-include>  </div>',
        controller: [ "$scope", function($scope) {
            $scope.globalView = {
                type: "analytics"
            };
            $scope.initialValues = {
                model: {
                    value: "SM-G900F"
                },
                network_operator_name: {
                    value: "Orange F"
                }
            };
        } ],
        activetab: "neighbors"
    }).when("/textDebug", {
        template: "<text-recognition-directive />",
        controller: "TextRecognitionController",
        activetab: "textDebug"
    }).when("/3DChart", {
        template: '<div ng-controller="MainController"> <ng-include src="\'nav.html\'"> </ng-include><div ng-controller="InteractionController"> <plot-directive matrix="matrix" interaction="interaction" normalize="True" ></3d-plot-directive> </div>',
        controller: [ "$scope", "dataAccessProvider", "legendProvider", function($scope, dataAccessProvider, legendProvider) {
            dataAccessProvider.csv("../data/preprocess/cluster/k-mean/clusters_centroids.csv", //"data/POQEMON/dataCompressed.csv",
            function(value) {
                $scope.matrix = value;
            }, function(error) {
                window.alert("couldn't load data : status \"" + error.statusText + '"');
            });
        } ],
        activetab: "3DChart"
    }).when("/clusters", {
        templateUrl: "app/components/clusters/clustersTemplate.html",
        controller: [ "$scope", "dataAccessProvider", "legendProvider", "filterProvider", "dataFeaturesEnum", function($scope, dataAccessProvider, legendProvider, filterProvider, dataFeaturesEnum) {
            dataAccessProvider.csv("data/data.csv", //"data/POQEMON/dataCompressed.csv",
            function(value) {
                var data = legendProvider.parseData(value, dataFeaturesEnum);
                $scope.data = [];
                for (var cluster = 0; cluster < 10; cluster++) {
                    $scope.data[cluster] = {};
                    filterProvider.setData(data);
                    filterProvider.setConditions([ {
                        feature: {
                            name: "cluster_index"
                        },
                        value: cluster.toString()
                    } ]);
                    var filteredData = filterProvider.getResult();
                    var featuresNames = [ "model", "network_operator_name", "speed_download", "network_type.group_name", "city" ];
                    featuresNames.forEach(function(featureIdx, idx) {
                        var feature = dataFeaturesEnum[featureIdx];
                        //Get the same colors of each feature accross all the filtered data.
                        var allLegend = new legendProvider.Feature(feature, legendProvider.getColumn(data, feature.name));
                        var filteredLegend = new legendProvider.Feature(feature, legendProvider.getColumn(filteredData, feature.name));
                        filteredLegend.distinctValuesArray.forEach(function(filteredValue, idx) {
                            filteredValue.color = allLegend.distinctValues[filteredValue.value].color;
                        });
                        $scope.data[cluster][featureIdx] = filteredLegend;
                    });
                }
            }, function(error) {
                window.alert("couldn't load data : status \"" + error.statusText + '"');
            });
        } ],
        activetab: "clusters"
    }).when("/test", {
        template: '<div ng-controller="MainController"> <ng-include src="\'nav.html\'"> </ng-include> <ng-include src="\'app/components/test/testTemplate.html\'" > </ng-include>  </div>',
        controller: [ "$scope", function($scope) {
            $scope.globalView = {
                type: "globe"
            };
        } ],
        activetab: "test"
    }).when("/graphForm", {
        template: '<div ng-controller="MainController"> <ng-include src="\'nav.html\'"> </ng-include> <ng-include src="\'app/components/graphForm/graphFormTemplate.html\'" > </ng-include>  </div>',
        controller: [ "$scope", function($scope) {
            $scope.globalView = {
                type: "globe"
            };
        } ],
        activetab: "graphForm"
    }).when("/anonymisationHierarchyShow", {
        template: '<force-layout-directive nodes="nodes" links="links" directed="true" text-dlg="textDlg" fill-dlg="fillDlg" radius-dlg="radiusDlg" node-opacity-dlg="nodeOpacityDlg" link-opacity-dlg="linkOpacityDlg" hovered="hovered"> {{hovered.name}} </force-layout-directive>',
        controller: [ "$scope", function($scope) {
            d3.json("../data/anonymisation/rho-uncertainty/Hierarchy/hierarchyDemo.json", function(json) {
                console.log(json);
                var getTuple = function(string) {
                    var re = /(u?'(.+)', u?'(.+)')/;
                    var match = string.match(re);
                    if (match) return {
                        feature: match[2],
                        value: match[3]
                    }; else return {
                        feature: "",
                        value: string
                    };
                };
                var getChildren = function(node, depth, maxDepth) {
                    var result = [ node ];
                    if (depth <= maxDepth) {
                        for (var i in node.children) result = result.concat(getChildren(node.children[i], depth + 1, maxDepth));
                    }
                    return result;
                };
                getNode = function(dict, node) {
                    if (!dict[node]) dict[node] = {
                        name: node,
                        children: [],
                        parent: []
                    };
                    return dict[node];
                };
                addLink = function(dict, source, target) {
                    source = getNode(dict, source);
                    target = getNode(dict, target);
                    source.children.push(target);
                    target.parent.push(source);
                };
                $scope.$apply(function() {
                    featureColor = {};
                    $scope.nodes = [];
                    $scope.links = [];
                    dictTmp = {};
                    for (var source in json) {
                        for (var targetIdx in json[source]) {
                            var target = json[source][targetIdx];
                            addLink(dictTmp, source, target);
                        }
                    }
                    for (var nodeIdx in dictTmp) {
                        var node = dictTmp[nodeIdx];
                        $scope.nodes.push(node);
                        for (targetIdx in node.children) {
                            var target = node.children[targetIdx];
                            $scope.links.push({
                                source: node,
                                target: target
                            });
                        }
                    }
                    $scope.hovered = null;
                    $scope.$watch("hovered", function(hovered, oldHovered) {
                        if (oldHovered) {
                            var children = getChildren(oldHovered, 0, 100);
                            for (var child in children) children[child]["hovered"] = false;
                        }
                        if (hovered) {
                            var children = getChildren(hovered, 0, 100);
                            for (var child in children) children[child]["hovered"] = true;
                        }
                    });
                    $scope.nodeOpacityDlg = function(d) {
                        if ($scope.hovered) {
                            if (d["hovered"]) return 1;
                            return .5;
                        }
                        return .5;
                    };
                    $scope.linkOpacityDlg = function(d) {
                        if ($scope.hovered) {
                            if (d.source["hovered"]) return 1;
                            return .5;
                        }
                        return .75;
                    };
                    $scope.textDlg = function(d) {
                        var text = getTuple(d.name).value;
                        if (text.match(/http:\/\/dbpedia.org\/resource\//)) return "DB:" + text.substring(28); else return text;
                    };
                    $scope.fillDlg = function(d) {
                        var feature = getTuple(d.name).feature;
                        if (!featureColor[feature]) featureColor[feature] = Object.keys(featureColor).length + 1;
                        return featureColor[feature];
                    };
                    $scope.radiusDlg = function(d) {
                        return getChildren(d, 0, 100).length;
                    };
                });
            });
        } ],
        activetab: "anonymisationHierarchyShow"
    }).when("/anonymisation", {
        // templateUrl : "app/components/hierarchy/template.html",
        template: "<ng-include src=\"'nav.html'\"> </ng-include> <ng-include src=\"'app/components/hierarchy/template.html'\" > </ng-include> ",
        activetab: "anonymisation"
    }).when("/ranking", {
        templateUrl: "app/components/ranking/rankingTemplate.html",
        controller: "RankingController",
        activetab: "clusters"
    }).otherwise({
        redirectTo: "/graphForm"
    });
} ]);

angular.module("apriori").controller("AprioriController", [ "$scope", "$http", "$compile", "textRecognitionService", function($scope, $http, $compile, nlpProvider) {
    var nlp = new nlpProvider();
    var scoreRegex = /(Lift|Conviction|Confidence|Leverage)/i;
    var numberRegex = /[0-9]+/;
    var floatRegex = /[0-9]*\.?[0-9]+/;
    var attributes = [ {
        regex: /(bytes_upload|bytes upload|upload bytes)/i,
        remplace: "bytes_upload"
    }, {
        regex: /(country)/i,
        remplace: "country"
    }, {
        regex: /(encryption)/i,
        remplace: "encryption"
    }, {
        regex: /(geo_accuracy|geo accuracy|accuracy geo)/i,
        remplace: "geo_accuracy"
    }, {
        regex: /(nat_type|nat type|type nat)/i,
        remplace: "nat_type"
    }, {
        regex: /(nsec_upload|nsec upload|upload nsec)/i,
        remplace: "nsec_upload"
    }, {
        regex: /(ping shortest|ping_shortest|shortest ping)/i,
        remplace: "ping_shortest"
    }, {
        regex: /(plattform|platform)/i,
        remplace: "plattform"
    }, {
        regex: /(speed download|speed_download|download speed|downloading speed)/i,
        remplace: "speed_download"
    }, {
        regex: /(speed upload|speed_upload|upload speed|uploading speed)/i,
        remplace: "speed_upload"
    }, {
        regex: /(test_if_bytes_upload|test if bytes upload)/i,
        remplace: "test_if_bytes_upload"
    }, {
        regex: /(testdl_if_bytes_download|testdl if bytes download)/i,
        remplace: "testdl_if_bytes_download"
    }, {
        regex: /(testdl_if_bytes_upload|testdl if bytes upload)/i,
        remplace: "testdl_if_bytes_upload"
    }, {
        regex: /(testul_if_bytes_download|testul if bytes download)/i,
        remplace: "testul_if_bytes_download"
    }, {
        regex: /(testul_if_bytes_upload|testul if bytes upload)/i,
        remplace: "testul_if_bytes_upload"
    }, {
        regex: /(total_bytes_download|total bytes download)/i,
        remplace: "total_bytes_download"
    }, {
        regex: /(total_bytes_upload|total bytes upload)/i,
        remplace: "total_bytes_upload"
    } ];
    var scenarii = [ {
        type: "maxResults",
        rule: [ {
            regex: /(Limit|Top|maximum)/i,
            remplace: "maxResults"
        }, {
            regex: numberRegex
        } ]
    }, {
        type: "orderBy",
        rule: [ {
            regex: /(order|order|orderby|ordonned|ranked)/i,
            remplace: "orderBy"
        }, {
            regex: scoreRegex
        } ]
    }, {
        type: "whereSup",
        rule: [ {
            regex: scoreRegex
        }, {
            regex: /(superior|greater|more|>)/i,
            remplace: ">"
        }, {
            regex: floatRegex
        } ]
    }, {
        type: "whereInf",
        rule: [ {
            regex: scoreRegex
        }, {
            regex: /(inferior|lesser|less|<)/i,
            remplace: "<"
        }, {
            regex: floatRegex
        } ]
    }, {
        type: "whereEq",
        rule: [ {
            regex: scoreRegex
        }, {
            regex: /(equal|equals|same|=)/i,
            remplace: "="
        }, {
            regex: floatRegex
        } ]
    } ];
    for (var i in attributes) {
        scenarii.push({
            type: "whereAntecedent",
            rule: [ {
                regex: /(Antecedent|Antecedence)/i,
                remplace: "Antecedent"
            }, attributes[i] ]
        });
        scenarii.push({
            type: "whereConsequent",
            rule: [ {
                regex: /(Consequent|Consequence)/i,
                remplace: "Consequent"
            }, attributes[i] ]
        });
    }
    nlp.Scenarii = scenarii;
    $scope.inputQuery = "top 1, ordered by Confidence and the consequent contains upload speed";
    $scope.transcribedQuery = [];
    $scope.$watch("inputQuery", function(value) {
        $scope.transcribedQuery = nlp.match(value);
    });
    $scope.$watch("transcribedQuery", function(value) {
        var query = window.location.protocol + "//" + window.location.hostname + ":8080/WebApplication1/webresources/Apriori?";
        for (var i in value) {
            switch (value[i].type) {
              case "maxResults":
                query += "&maxResults=" + value[i].rule[1];
                break;

              case "orderBy":
                query += "&orderBy=" + value[i].rule[1].charAt(0).toUpperCase() + value[i].rule[1].slice(1).toLowerCase() + " DESC";
                break;

              case "whereSup":
              case "whereInf":
              case "whereEq":
                query += "&where=" + value[i].rule[0].charAt(0).toUpperCase() + value[i].rule[0].slice(1).toLowerCase() + value[i].rule[1] + value[i].rule[2];
                break;

              case "whereAntecedent":
                query += "&Antecedent=Attribute='" + value[i].rule[1] + "'";
                break;

              case "whereConsequent":
                query += "&Consequent=Attribute='" + value[i].rule[1] + "'";
                break;

              default:            }
        }
        console.log(query);
        $http.get(query).success(function(data, status, headers, config) {
            $scope.rules = data;
        }).error(function(data, status, headers, config) {
            $scope.rules = data;
        });
    }, true);
    $scope.rules = [];
    $scope.nodes = [];
    $scope.links = [];
    $scope.interaction = {
        clicked: null,
        hovered: null
    };
    //$http.get('http://152.81.97.57:8080/WebApplication1/webresources/Associate').
    //  success(function (data, status, headers, config) {
    //      $scope.rules = data;
    //  }).
    //  error(function (data, status, headers, config) {
    //      $scope.rules = data;
    //  });
    $scope.$watch("rules", function(value) {
        var nodes = [], links = [];
        for (var i in value) {
            var rule = value[i];
            nodes.push(rule);
            for (var j in rule.Antecedent) {
                var antecedent = rule.Antecedent[j];
                if (nodes.filter(function(n) {
                    return angular.equals(n, antecedent);
                }).length == 0) nodes.push(antecedent); else antecedent = nodes.filter(function(n) {
                    return angular.equals(n, antecedent);
                })[0];
                links.push({
                    source: antecedent,
                    target: rule
                });
            }
            for (var k in rule.Consequent) {
                var consequent = rule.Consequent[k];
                if (nodes.filter(function(n) {
                    return angular.equals(n, consequent);
                }).length == 0) nodes.push(consequent); else consequent = nodes.filter(function(n) {
                    return angular.equals(n, consequent);
                })[0];
                links.push({
                    source: rule,
                    target: consequent
                });
            }
        }
        $scope.nodes = nodes;
        $scope.links = links;
        $scope.radiusDlg = function(d) {
            return d.TotalSupport ? d.TotalSupport : 0;
        };
        $scope.fillDlg = function(d) {
            return d.Lift ? d.Lift : 0;
        };
        //$scope.titleDlg = function (d) { return d.Confidence ? "Confidence : " + d.Confidence + " - Lift : " + d.Lift : d.Attribute + ": " + d.Value; };
        $scope.textDlg = function(d) {
            return d.Attribute ? d.Attribute : "";
        };
    });
} ]);

angular.module("apriori").directive("associateDirective", [ "$http", function($http) {
    function link(scope, element, attrs) {
        scope.$watch("clicked", function(value) {
            for (var i in scope.rules) scope.rules[i].isOpen = scope.check(value, scope.rules[i]);
        });
        scope.check = function(object, rule) {
            if (!object) return false; else if (object == rule) return true; else if (rule.Antecedent.filter(function(e) {
                return e.Attribute == object.Attribute && e.Value == object.Value;
            }).length != 0 || rule.Consequent.filter(function(e) {
                return e.Attribute == object.Attribute && e.Value == object.Value;
            }).length != 0) return true; else return false;
        };
    }
    return {
        restrict: "E",
        scope: {
            rules: "=",
            hovered: "=",
            clicked: "="
        },
        templateUrl: function(elem, attrs) {
            return "app/components/apriori/views/associate.html";
        },
        link: link
    };
} ]);

angular.module("apriori").filter("jsonFilter", function() {
    return function(json) {
        var result = "";
        for (var i in json) {
            for (var j in json[i]) {
                result += json[i][j] + "<br/>";
            }
        }
        return result;
    };
});

angular.module("apriori").directive("ruleDirective", [ "$http", function($http) {
    function link(scope, element, attrs) {}
    return {
        restrict: "E",
        scope: {
            rule: "="
        },
        templateUrl: function(elem, attrs) {
            return "app/components/apriori/views/rule.html";
        },
        link: link
    };
} ]);

angular.module("neighbors").controller("NeighborsController", [ "$scope", "$http", "cancellableHttpService", function($scope, $http, cancellableHttpService) {
    $scope.neighbor = {};
    $scope.neighborArray = [];
    $scope.loading = false;
    var cancellableHttp = new cancellableHttpService();
    $scope.$watch(function() {
        var impactingValues = [];
        $scope.form.where.forEach(function(value) {
            if (value.value) impactingValues.push(value.value);
        });
        return impactingValues;
    }, function(value, oldValue) {
        if (value == oldValue) return;
        value = $scope.form.where;
        var sample = {};
        for (where in value) {
            if (value[where].feature.type == "Date") sample[value[where].feature.name] = value[where].value.timestamp; else sample[value[where].feature.name] = value[where].value;
        }
        var promise = cancellableHttp.get("/poqemon/poqemon/poqemon/data/Scripts/cluster/k-mean/nearestNeighbors.py", {
            params: {
                sample: sample
            }
        });
        $scope.loading = true;
        promise.success(function(data) {
            $scope.loading = false;
            $scope.neighbor = data;
            $scope.neighborArray = [];
            for (feature in data) $scope.neighborArray.push({
                feature: feature,
                value: data[feature]
            });
        });
    }, true);
} ]);

/**
 * @ngdoc controller
 * @name home.controllers.FormController
 *
 * @description contains the behavior for retreiving, selecting and filtering data.
 * 
 */
angular.module("home").controller("GraphFormController", [ "$scope", "$http", "$timeout", "dataAccessProvider", "legendProvider", "filterProvider", "dataFeaturesEnum", function($scope, $http, $timeout, dataAccessProvider, legendProvider, filterProvider, dataFeaturesEnum) {
    //scope
    $scope.raw = [];
    $scope.filtered = [];
    $scope.data = {
        legend: [],
        filtered: [],
        features: Object.keys(dataFeaturesEnum).map(function(key) {
            return dataFeaturesEnum[key];
        })
    };
    $scope.legendized = {};
    $scope.selected;
    var baseLegend = {};
    function getBaseLegend(featureIdx) {
        if (!baseLegend[featureIdx]) {
            var feature = dataFeaturesEnum[featureIdx];
            baseLegend[feature.name] = new legendProvider.Feature(feature, legendProvider.getColumn($scope.raw, feature.name));
        }
        return baseLegend[featureIdx];
    }
    function getFilteredLegend(featureIdx) {
        var feature = dataFeaturesEnum[featureIdx];
        var filteredLegend = new legendProvider.Feature(feature, legendProvider.getColumn($scope.filtered, feature.name));
        filteredLegend.getDistinctValuesArray().forEach(function(filteredValue, idx) {
            filteredValue.color = getBaseLegend(feature.name).getDistinctValues()[filteredValue.value].color;
        });
        return filteredLegend;
    }
    //scope.data behavior
    dataAccessProvider.csv("data/data.csv", //"data/POQEMON/dataCompressed.csv",
    function(value) {
        $scope.raw = legendProvider.parseData(value, dataFeaturesEnum);
    }, function(error) {
        window.alert("couldn't load data : status \"" + error.statusText + '"');
    });
    $scope.$watch("raw", function(value) {
        if (!value.length) return;
        filterProvider.setData(value);
        filterProvider.setConditions([]);
        $scope.filtered = filterProvider.getResult();
        $scope.addChart("speed_download");
        $scope.selectChart("speed_download");
    });
    $scope.$watch("filtered", function(value) {
        for (var featureIdx in $scope.legendized) {
            $scope.legendized[featureIdx] = getFilteredLegend(featureIdx);
        }
    });
    $scope.addChart = function(featureIdx) {
        $scope.legendized[featureIdx] = getFilteredLegend(featureIdx);
    };
    $scope.removeChart = function(featureIdx) {
        delete $scope.legendized[featureIdx];
    };
    $scope.selectChart = function(featureIdx) {
        $scope.selected = featureIdx;
    };
    $scope.openGraphFormModal = function(urlTemplate) {
        var modal = $scope.openModal(urlTemplate, $scope, function(result) {
            $scope.addChart(result.name);
        });
        modal.opened.then(function() {});
    };
    var Where = function(feature) {
        this.feature = feature;
        /**
             * @ngdoc property
             * @name home.controllers.FormController.Where:value
             * @description The value used to filter
             */
        this.value = null;
        this.minValue = null;
        this.maxValue = null;
        this.timeout = 1e3;
        var _play = false;
        this.indexValue = null;
    };
    $scope.where = [];
    //scope.form behavior
    $scope.addWhere = function(feature, where) {
        var whereNewRef = new Where();
        if (where) {
            for (var i in where) whereNewRef[i] = where[i];
        }
        if (feature) whereNewRef.feature = feature; else whereNewRef.feature = form.select;
        $scope.where.push(whereNewRef);
    };
    $scope.removeWhere = function(index) {
        if (index == -1) $scope.where = []; else $scope.where.splice(index, 1);
    };
    //we watch the "where" conditions to filter the data and create a new legend.
    //because the Feature objects are really big, we have to obsere only some fields
    //and only call the callback when there are effectives changes in the conditions
    $scope.$watch(function() {
        var impactingValues = [];
        $scope.where.forEach(function(value) {
            if (value.minValue !== undefined && value.minValue !== null || value.maxValue !== undefined && value.maxValue !== null || value.value !== undefined && value.value !== null) impactingValues.push({
                value: value.value,
                minValue: value.minValue,
                maxValue: value.maxValue
            });
        });
        return impactingValues;
    }, function(newVal, oldVal) {
        var startTime = new Date();
        if (newVal == oldVal) return;
        filterProvider.setConditions($scope.where);
        $scope.filtered = filterProvider.getResult();
        console.log("filter : " + (new Date() - startTime));
    }, true);
} ]);

/**
 * @ngdoc controller
 * @name home.controllers.FormController
 *
 * @description contains the behavior for retreiving, selecting and filtering data.
 * 
 */
angular.module("home").controller("GenerateHierarchyController", [ "$scope", "$http", "$timeout", "dataAccessProvider", "legendProvider", "colorProvider", "filterProvider", "dataFeaturesEnum", "dataTypeEnum", "cancellableHttpService", "Node", "jobQueueService", "saveFile", function($scope, $http, $timeout, dataAccessProvider, legendProvider, colorProvider, filterProvider, dataFeaturesEnum, dataTypeEnum, cancellableHttpService, Node, jobQueueService, saveFile) {
    $scope.loading = false;
    var cancellableHttp = new cancellableHttpService();
    var rhoUncertainty = function(H, D, Is, Rho) {
        if (H) {
            var promise = cancellableHttp.request({
                // headers: {"Content-Type":"application/json"},
                // data :  JSON.stringify({H: H, Is: Is, Rho: Rho}),
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                data: "H=" + JSON.stringify(H) + "&Is=" + JSON.stringify(Is) + "&Rho=" + Rho,
                //"&D=" + JSON.stringify(D) +
                url: "http://127.0.0.1:8080/RhoUncertainty",
                method: "POST"
            }, function(data) {}, function(error) {
                console.error(error);
            }, false);
        }
    };
    $scope.input = {};
    $scope.input.transactions = null;
    $scope.input.hierarchy = null;
    $scope.input.Rho = .5;
    $scope.input.Is = [ "County" ];
    $scope.input.transactionsPath = null;
    $scope.progress = new jobQueueService.Progress();
    $scope.exportHierarchy = function() {
        var content = JSON.stringify(getHierarchy());
        saveFile("hierarchy.json", content);
    };
    $scope.anonymize = function() {
        rhoUncertainty(JSON.stringify(getHierarchy()), "", [ "time" ], .5);
    };
    // $scope.transactionsPath = "app/components/hierarchy/transactions.csv"
    // $scope.hierarchyPath = "app/components/hierarchy/hierarchy.json"
    $scope.toggleIs = function(value) {
        var index = $scope.input.Is.indexOf(value);
        if (index != -1) {
            $scope.input.Is.splice(index, 1);
        } else {
            $scope.input.Is.push(value);
        }
    };
    $scope.$watch("input.transactionsPath", function(value, oldValue) {
        if (value && value != oldValue) {
            $scope.input.hierarchy = new Node("ALL");
            $scope.progress.setLabel("Loading file ...");
            $scope.progress.setPercent(0);
            handleTransactionsWorker.postMessage(value);
        }
    });
    // watch tranasctions to generate hierarchy if doesn't exist.
    // $scope.$watch("input.transactions", function(value){
    //     if(value && !$scope.hierarchyPath){
    //         var features = [];
    //         for(var feature in dataFeaturesEnum){
    //             if(dataFeaturesEnum[feature].redondant || value[0][feature] === undefined) continue;
    //             features.push(feature);
    //         }
    //     }
    // })
    // $scope.$watch("mappingPath", function(value){
    //     if(value){
    //         dataAccessProvider.json(value,
    //             function(data){
    //                 $scope.mapping =  data;
    //             },
    //             function(error){
    //                 console.log(error);
    //             });
    //     }
    // });
    // $scope.$watch("hierarchyPath", function(value){
    // 	if(value){
    // 		dataAccessProvider.json(value,
    // 			function(data){
    //                    var root = null;
    //                    var dictRef = {};
    //                    Node.visit("ALL",
    //                        function(parent){
    //                            if(parent == "ALL"){
    //                                var node = Node.deserialize(parent);
    //                                root = node;
    //                                dictRef[parent] = node;
    //                            } 
    //                            if(dictRef[parent]){
    //                                var node = dictRef[parent];
    //                                if(data[parent]){
    //                                    for(var childIdx in data[parent]){
    //                                        var child = Node.deserialize(data[parent][childIdx]);
    //                                        if(!data[data[parent][childIdx]])
    //                                            child.value = true;
    //                                        if(!node.children)
    //                                            node.children = [];
    //                                        node.children.push(child);
    //                                        dictRef[data[parent][childIdx]] = child;
    //                                    }
    //                                }
    //                            }
    //                        },
    //                        function(parent){
    //                            if(data[parent])
    //                                return data[parent];
    //                            else
    //                                return [];
    //                        });
    //                    $scope.input.hierarchy = root;
    // 			},
    // 			function(error){
    // 				console.log(error);
    // 			});
    // 	}
    // });
    // watch hierarchy to serialize and send to the script
    // $scope.$watch(function(){
    //        var watch = {H:[]};
    //        Node.visit($scope.hierarchy,
    //            function(node){
    //                var n = node.getAllChildren().length;
    //                watch.H.push({name: node['name'], children: n});
    //            },
    //            function(parent){
    //                return parent.getAllChildren();
    //            });
    //        watch['Rho'] = $scope.Rho;
    //        watch['D'] = $scope.transactions;
    //        watch['Is'] = $scope.Is;
    //        return watch;
    //    }, function(value, oldValue){
    //        if(value == oldValue)
    //            return;
    //        value = $scope.hierarchy; //todo: not clean
    // 	
    //        Node.visit(value,
    //            function(parent){
    //                var children =  parent.getAllChildren();
    //                if (children.length){
    //                    var realChildren = []
    //                    for(var node in children){
    //                        if(children[node].isLeaf() || children[node].getAllChildren().length)
    //                            realChildren.push(Node.serialize(children[node]));
    //                    }
    //                    links[Node.serialize(parent)] = realChildren;
    //                }
    //            },
    //            function(parent){
    //                return parent.getAllChildren();
    //            });
    //        // console.log(links);
    //        // var Is = [];
    //        // for(var feature in $scope.Is)
    //        //     Is.push("u'" + $scope.Is[feature] + "'");
    //        rhoUncertainty(links, $scope.transactions,  $scope.Is, $scope.Rho);
    // }, true);
    function getHierarchy() {
        var links = {};
        Node.visit($scope.input.hierarchy, function(parent) {
            var children = parent.getAllChildren();
            if (children.length) {
                var realChildren = [];
                for (var node in children) {
                    if (children[node].isLeaf() || children[node].getAllChildren().length) realChildren.push(Node.serialize(children[node]));
                }
                links[Node.serialize(parent)] = realChildren;
            }
        }, function(parent) {
            return parent.getAllChildren();
        });
        return links;
    }
    function contained(A, B) {
        if (A.indexOf(B) != -1) return true; else return false;
    }
    $scope.$watch("Filter", function(text) {
        Node.visit($scope.input.hierarchy, function(node) {
            if (node === $scope.input.hierarchy) return;
            if (!text || contained(node.name, text) || node.feature && contained(node.feature.name, text)) node.hidden = false; else {
                node.hidden = true;
            }
        }, function(parent) {
            return parent.getAllChildren;
        });
    });
    $scope.generateTree = function() {
        var branchs = $scope.input.hierarchy.getAllChildren();
        for (var branchIdx in branchs) {
            $scope.generateBranch(branchs[branchIdx]);
        }
    };
    $scope.generateBranch = function(node, legend, callBack) {
        if (node.isLeaf()) return;
        if (node.feature.type == "RANGE") {
            //todo: doesn't work on each situation
            // - when node isn't root
            // - when feature is not from the transactions, but from a hierarchy
            node.children = null;
            var values = legend.values.filter(function(d) {
                return angular.isDefined(d) && d !== "" && d !== "0";
            });
            for (var valueIdx in values) {
                values[valueIdx] = legendProvider.parse(values[valueIdx], node.feature.type);
            }
            var feature = new legendProvider.Feature(legend, values);
            node._children = splitContinuousValues(feature, 0, 5)._children;
            callBack(node);
        } else if (node.feature.type == "DATE") {
            for (nodeIdx in node.getAllChildren()) {
                var child = node.getAllChildren()[nodeIdx];
                child.date = legendProvider.parseDate(child.name);
                if (!child.date) node.removeChild(child);
            }
            node._children = splitTime(node.getAllChildren(), 1);
            callBack(node);
        } else {
            callBack(node);
        }
    };
    var splitContinuousValues = function(feature, level, depth) {
        var median = feature.getPercentile(.5);
        var min = feature.getPercentile(0);
        var max = feature.getPercentile(1);
        var lowValues = feature.values.filter(function(d) {
            return d <= median;
        });
        var highValues = feature.values.filter(function(d) {
            return d > median;
        });
        var node = new Node("[" + min + " , " + max + "]", null, null, false);
        node["_children"] = [];
        if (level < depth && lowValues.length > 1 && highValues.length > 1) {
            var lowLegend = new legendProvider.Feature(feature, lowValues);
            node._children.push(splitContinuousValues(lowLegend, level + 1, depth));
            var highLegend = new legendProvider.Feature(feature, highValues);
            node._children.push(splitContinuousValues(highLegend, level + 1, depth));
        } else {
            for (var value in feature.getDistinctValues()) {
                node._children.push(new Node(value, null, null, true));
            }
        }
        return node;
    };
    var splitTime = function(nodes, level) {
        var monthNames = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ];
        var delegate;
        if (level == 1) delegate = function(date) {
            return date.getFullYear();
        }; else if (level == 2) delegate = function(date) {
            return monthNames[date.getMonth()] + " " + date.getFullYear();
        }; else if (level == 3) delegate = function(date) {
            return date.getDate() + " " + monthNames[date.getMonth()] + " " + date.getFullYear();
        }; else return nodes;
        var values = {};
        for (nodeIdx in nodes) {
            var node = nodes[nodeIdx];
            var value = delegate(node.date);
            if (value in values) values[value].push(node); else values[value] = [ node ];
        }
        var children = [];
        for (value in values) {
            var child = new Node(value, null, null, null);
            child._children = splitTime(values[value], level + 1);
            children.push(child);
        }
        return children;
    };
    var getChildrenMappingValues = function(node, callBack) {
        var count = 0;
        var children = node.getAllChildren();
        var centralizedCallback = function(value) {
            if (value) {
                count++;
                if (children.length == count) callBack();
            }
        };
        children.forEach(function(d) {
            d.getMappingValues(centralizedCallback);
        });
    };
    var workerService = new jobQueueService.Worker();
    //include vendors
    workerService.addDependencieURL("http://localhost/poqemon/poqemon/application/vendors/d3js/d3.v3.js");
    workerService.addDependencieURL("http://localhost/poqemon/poqemon/application/vendors/angular/angular.js");
    //include angular elements
    workerService.addDependencieURL("http://localhost/poqemon/poqemon/application/min/poqemon.min.js");
    workerService.addAngularModule("home");
    workerService.addAngularModule("graphs");
    workerService.addAngularProvider("legendProvider");
    workerService.addAngularProvider("dataFeaturesEnum");
    workerService.addAngularProvider("Node");
    //include local functions
    //workerService.addDependencie("id", 0);
    workerService.addDependencieFunction("generateBranch", $scope.generateBranch);
    workerService.addDependencieFunction("splitContinuousValues", splitContinuousValues);
    workerService.addDependencieFunction("getChildrenMappingValues", getChildrenMappingValues);
    workerService.addDependencieFunction("splitTime", splitTime);
    var handleTransactionsDelegate = function() {
        var generateHierarchy = function(transactions) {
            var features = [];
            for (var feature in dataFeaturesEnum) {
                //the value is null if the cell is empty, but undefined if the column is empty
                if (dataFeaturesEnum[feature].redondant || transactions[0][feature] === undefined) continue;
                //dataFeaturesEnum[feature].redondant || 
                features.push(feature);
            }
            var progress = 0;
            for (featureIdx in features) {
                var feature = dataFeaturesEnum[features[featureIdx]];
                var legend = legendProvider.getLegend(transactions, feature);
                var branch = new Node(features[featureIdx], null, feature, false);
                leaves = [];
                for (var leaf in legend.getDistinctValues()) {
                    if (angular.isDefined(legend.getDistinctValues()[leaf].value) && legend.getDistinctValues()[leaf].value !== "" && legend.getDistinctValues()[leaf].value !== "0" && legend.getDistinctValues()[leaf].value !== 0) {
                        var leafObject = new Node(leaf, null, feature, true);
                        leafObject.parent = branch;
                        leaves.push(leafObject);
                    }
                }
                branch._children = leaves;
                branch.children = [];
                //strategies to pass data :http://developerblog.redhat.com/2014/05/20/communicating-large-objects-with-web-workers-in-javascript/
                //try sending a ref.
                generateBranch(branch, legend, function(result) {
                    // self.postMessage(JSON.stringify(result))
                    self.postMessage({
                        object: Node.getClone(result),
                        percent: ++progress / features.length * 100
                    });
                });
            }
        };
        self.onmessage = function(message) {
            var file = message.data;
            var reader = new FileReader();
            reader.onload = function(loadEvent) {
                var data = d3.csv.parse(loadEvent.target.result);
                generateHierarchy(data);
            };
            reader.readAsText(file);
        };
    };
    var handleTransactionsWorker = workerService.getWorker(handleTransactionsDelegate);
    handleTransactionsWorker.onmessage = function(e) {
        $scope.$apply(function() {
            // $scope.input.hierarchy.addChild(Node.fromString(e.data));
            var child = Node.fromClone(e.data.object);
            child.collapse();
            $scope.input.hierarchy.addChild(child);
            $scope.progress.setPercent(e.data.percent);
        });
    };
    handleTransactionsWorker.onerror = function(error) {
        window.alert("Error While loading the file");
        $scope.progress.setPercent(100);
    };
    $scope.canRemoveNode = function(node) {
        return node.parent && !node.leaf;
    };
    $scope.canAddNode = function(node) {
        return !node.parent.leaf;
    };
    //todo : Move should be implemented in the Node class, but canMove should be implemented in Node or in the controller ?
    //a node can be moved if its new parent isn't a leaf (ie: a value node)
    //and if it is moved in the same branch (ie, the branch of the same feature)
    $scope.canMoveNode = function(oldNode, newNode) {
        if (!newNode.parent.leaf && oldNode.feature && newNode.parent.feature && oldNode.feature.name == newNode.parent.feature.name) return true; else return false;
    };
    // colorScale =  d3.scale.category10();
    // $scope.fillDlg =  function(d){
    //     if($scope.node == d)
    //         return "red";
    //     return colorScale(d.type);
    // }
    $scope.fillDlg = function(node) {
        if (node._children && node._children.length != 0) return "lightsteelblue"; else if (node.children && node.children.length != 0) return "#fff"; else if (node.mappingValue) return "lightgreen"; else return "orange";
    };
} ]);

/**
 * @ngdoc controller
 * @name home.controllers.FormController
 *
 * @description contains the behavior for retreiving, selecting and filtering data.
 * 
 */
angular.module("home").controller("FormController", [ "$scope", "$http", "$timeout", "dataAccessProvider", "legendProvider", "filterProvider", "dataFeaturesEnum", function($scope, $http, $timeout, dataAccessProvider, legendProvider, filterProvider, dataFeaturesEnum) {
    //scope
    /**
         * @ngdoc property
         * @name home.controllers.FormController:data
         * @description field containing the data to display in the views
         * contains :
         *
         *   all: all the data from the csv
         *   features: all the properties in the data from the csv 
         *   filtered: all the data after the filter
         *   legend: is an array of Features
         *
         * @requires home.model.legendProvider.Feature
         */
    var data = {
        all: [],
        //all the data from the csv
        features: [],
        //all the properties in the data from the csv 
        filtered: [],
        //all the data after the filter
        legend: []
    };
    $scope.data = data;
    /**
         * @ngdoc property
         * @name home.controllers.FormController:form
         * @description field containing the informations about which feature is selected and the filtering conditions
         * contains :
         *
         *   select: the property selected between all the other properties in data.features
         *   where: the array of conditions [{feature, values}] 
         */
    var form = {
        select: {},
        //the property selected between all the other properties in data.features
        where: []
    };
    $scope.form = form;
    //scope.data behavior
    dataAccessProvider.csv("data/data.csv", //"data/POQEMON/dataCompressed.csv",
    function(value) {
        data.all = legendProvider.parseData(value, dataFeaturesEnum);
    }, function(error) {
        window.alert("couldn't load data : status \"" + error.statusText + '"');
    });
    $scope.$watch("data.all", function(value) {
        if (!value.length) return;
        filterProvider.setData(value);
        filterProvider.setConditions([]);
        data.filtered = filterProvider.getResult();
        for (var i in value[0]) {
            data.features.push(new legendProvider.Feature(dataFeaturesEnum[i]));
        }
        //to ensure that everything is set at the beginning
        form.select = data.features.filter(function(d) {
            return d.alias == "speed download";
        })[0];
        for (feature in $scope.initialValues) {
            var initialFeature = new legendProvider.Feature(dataFeaturesEnum[feature], legendProvider.getColumn(value, feature));
            var initialCondition = new Where();
            for (condition in $scope.initialValues[feature]) {
                initialCondition[condition] = $scope.initialValues[feature][condition];
            }
            // form.addWhere(data.features.filter(function (d) { return d.alias == feature; })[0], initialCondition);
            form.addWhere(initialFeature, initialCondition);
        }
    });
    /**
         * @ngdoc class
         * @name home.controllers.FormController.Where
         * @description class representing a condition on a feature
         * todo : put it inside a service ?
         * @requires home.model.legendProvider.Feature
         */
    var Where = function(feature) {
        /**
             * @ngdoc property
             * @name home.controllers.FormController.Where:feature
             * @description The feature on which the condition is applied
             */
        this.feature = feature;
        /**
             * @ngdoc property
             * @name home.controllers.FormController.Where:value
             * @description The value used to filter
             */
        this.value = null;
        this.minValue = null;
        this.maxValue = null;
        this.timeout = 1e3;
        var _play = false;
        this.indexValue = null;
        /**
             * @ngdoc function
             * @name home.controllers.FormController.Where:play
             * @description used to change values of the filter one by one, in the order
             */
        this.play = function(setter) {
            if (setter) {
                _play = !_play;
                this._playing();
            }
            return _play;
        };
        this.searchNextValue = function() {
            if (!this.indexValue) {
                this.indexValue = this.feature.distinctValuesArray[0];
                this.value = this.feature.distinctValuesArray[0].value;
            } else {
                var index = this.feature.distinctValuesArray.indexOf(this.indexValue) + 1;
                if (index == this.feature.distinctValuesArray.length) return false;
                this.indexValue = this.feature.distinctValuesArray[index];
                this.value = this.feature.distinctValuesArray[index].value;
            }
            return true;
        };
        var savedReference = this;
        this._playing = function() {
            if (_play) {
                if (!savedReference.searchNextValue()) return _play = false;
                $timeout(savedReference._playing, savedReference.timeout);
            }
        };
    };
    //scope.form behavior
    form.addWhere = function(feature, where) {
        var whereNewRef = new Where();
        if (where) {
            for (var i in where) whereNewRef[i] = where[i];
        }
        if (feature) whereNewRef.feature = feature; else whereNewRef.feature = form.select;
        form.where.push(whereNewRef);
    };
    form.removeWhere = function(index) {
        form.where.splice(index, 1);
    };
    /**
         * @ngdoc function
         * @name home.controllers.FormController:changeWhereFeature
         * @description called when the conditions are changed to apply the new filter
         * todo: we also watch the conditions array. I don't remember what are the differences.
         * 
         * @requires home.model.filterProvider
         */
    // form.changeWhereFeature = function (index) {
    //     form.where[index].feature.setValues(legendProvider.getColumn(data.all, form.where[index].feature.name));
    //     form.where[index].value = form.where[index].value ? form.where[index].value : "";
    //     form.where[index].minValue = form.where[index].minValue ? form.where[index].minValue : form.where[index].feature.minValue;
    //     form.where[index].maxValue = form.where[index].maxValue ? form.where[index].maxValue : form.where[index].feature.maxValue;
    //     filterProvider.setConditions(form.where);
    //     data.filtered = filterProvider.getResult();
    //     //updateLegend();
    // }
    //we watch the "where" conditions to filter the data and create a new legend.
    //because the Feature objects are really big, we have to obsere only some fields
    //and only call the callback when there are effectives changes in the conditions
    $scope.$watch(function() {
        var impactingValues = [];
        form.where.forEach(function(value) {
            if (value.minValue !== undefined && value.minValue !== null || value.maxValue !== undefined && value.maxValue !== null || value.value !== undefined && value.value !== null) impactingValues.push({
                value: value.value,
                minValue: value.minValue,
                maxValue: value.maxValue,
                name: value.feature.name
            });
        });
        return impactingValues;
    }, function(newVal, oldVal) {
        if (newVal == oldVal) return;
        filterProvider.setConditions(form.where);
        data.filtered = filterProvider.getResult();
        updateLegend();
    }, true);
    $scope.$watch("form.select", function(value) {
        updateLegend();
    });
    //Watch if change feature
    $scope.$watch(function() {
        // Store min and max value of each feature
        var impactingValues = [];
        for (i = 0; i < form.where.length; i++) {
            impactingValues[i] = {};
            impactingValues[i].minValue = form.where[i].feature.minValue;
            impactingValues[i].name = form.where[i].feature.name + i;
            impactingValues[i].maxValue = form.where[i].feature.maxValue;
            impactingValues[i].value = form.where[i].feature.value;
        }
        return impactingValues;
    }, function(newVal, oldVal) {
        // For each feature, if new values : update input text
        for (i = 0; i < form.where.length; i++) {
            if (oldVal[i] && newVal[i].name != oldVal[i].name) {
                form.where[i].value = newVal[i].value;
                form.where[i].minValue = newVal[i].minValue;
                form.where[i].maxValue = newVal[i].maxValue;
            }
        }
    }, true);
    /**
         * @ngdoc function
         * @name home.controllers.FormController:updateLegend
         * @description instantiate a new Feature object when we select a feature in the form.
         * it would have been too long to instantiate a Feature for each row at the beginning. 
         * @requires home.model.legendProvider.Feature
         */
    function updateLegend() {
        console.log("update Legend");
        if (!form.select.name) return;
        data.legend = new legendProvider.Feature(form.select, legendProvider.getColumn(data.filtered, form.select.name));
    }
    /**
         * @ngdoc function
         * @name home.controllers.FormController:openFormModal
         * @description call the openModal from the MainController to select a feature.
         * this method is called from the template.
         * 
         * @requires home.model.MainController
         */
    $scope.openFormModal = function(urlTemplate, object, ref) {
        var modal = $scope.openModal(urlTemplate, $scope, function(result) {
            result.setValues(legendProvider.getColumn(data.all, result.name));
            object[ref] = result;
        });
        modal.opened.then(function() {});
    };
} ]);

/**
 * @ngdoc controller
 * @name home.controllers.InteractionController
 *
 * @description contains everything needed for synchronizing interaction in views.
 * 
 */
angular.module("home").controller("InteractionController", [ "$scope", function($scope) {
    /**
     * @ngdoc function
     * @name home.controllers.InteractionController.List
     * @description Class respresenting a unique array
     */
    function List() {
        var _list = [];
        this.set = function(object) {
            if (this.get(0) != object) {
                $scope.$apply(function() {
                    if (object) _list = [ object ]; else _list = [];
                });
            }
        };
        this.get = function(index) {
            if (isNaN(index)) return _list;
            return _list[index];
        };
        this.add = function(object) {
            if (object && !this.contains(object)) {
                _list.push(object);
                $scope.$apply();
                return true;
            } else return false;
        };
        this.remove = function(object) {
            if (object) {
                var index = _list.indexOf(object);
                if (index != -1) {
                    $scope.$apply(function() {
                        _list.splice(index, 1);
                    });
                }
            } else _list = [];
        };
        this.contains = function(object) {
            if (_list.indexOf(object) != -1) return true; else return false;
        };
        this.toggle = function(object) {
            if (object) {
                if (!this.add(object)) this.remove(object);
            }
        };
    }
    /**
     * @ngdoc property
     * @name home.controllers.InteractionController:interaction
     * @description Unique arrays for the interactions between the views. 
     * Contains the nodes (rows) and features (columns) emphasized (or hovered) and selected (clicked on) inside the views
     * keeping this inside the scope enables the selection of some data accross the views.
     */
    var interaction = {};
    interaction.node = {
        emphasized: new List(),
        selected: new List()
    };
    interaction.feature = {
        emphasized: new List(),
        selected: new List()
    };
    $scope.$watch("form.select", function() {
        interaction.feature.emphasized.remove();
        interaction.feature.selected.remove();
        interaction.node.emphasized.remove();
        interaction.node.selected.remove();
    });
    $scope.$watch("form.where", function() {
        interaction.feature.emphasized.remove();
        interaction.feature.selected.remove();
        interaction.node.emphasized.remove();
        interaction.node.selected.remove();
    });
    $scope.interaction = interaction;
} ]);

/**
 * @ngdoc controller
 * @name home.controllers.MainController
 *
 * @description controller handling the selection of the view to display
 * 
 */
angular.module("home").controller("MainController", [ "$scope", "$modal", "$document", "$route", function($scope, $modal, $document, $route) {
    $scope.$route = $route;
    /**
     * @ngdoc property 
     * @name home.controllers.MainController:globalView
     * @description Which view to display (globe or map) 
     */
    //$scope.globalView = { type: "globe" };
    $scope.today = new Date();
    /**
     * @ngdoc property 
     * @name home.controllers.MainController:detailedView
     * @description Which "detailed" view to display (the form, histogram, or details) 
     */
    $scope.detailedView = {
        type: "form",
        view: {
            form: false,
            barChart: false,
            legend: false
        }
    };
    /**
     * @ngdoc property 
     * @name home.controllers.MainController:cameraPosition
     * @description The camera position to keep the position between the globe and map view. 
     * todo : the current format ({latitude, longitude, radius}) is from leaflet. Change it to a boundingBox ? 
     */
    $scope.cameraPosition = {
        latitude: 48.8567,
        longitude: 2.3508,
        radius: 5
    };
    /**
     * @ngdoc function 
     * @name home.controllers.MainController:toggleTab
     * @description Behavior to hide the tab containing the detailed views.
     */
    $scope.toggleTab = function(d) {
        // If view already open: type = empty
        $scope.detailedView.type = $scope.detailedView.type == d ? "" : d;
        if (!$scope.detailedView.type.length) {
            // If no type: hide tabs
            angular.element(".tab-content").hide();
            for (i in $scope.detailedView.view) {
                $scope.detailedView.view[i] = false;
            }
        } else {
            // If type: show tabs
            angular.element(".tab-content").show();
        }
    };
    /**
     * @ngdoc function 
     * @name home.controllers.MainController:openModal
     * @description Util proxy function to open a Modal with $modal from angular-bootstrap-ui 
     * @link http://angular-ui.github.io/bootstrap/#/modal
     * @param {string} templateUrl url of the template included inside the modal
     * @param {scope} scope scope injected inside the modal
     * @param {function} close delegate called on result.
     */
    $scope.openModal = function(templateUrl, scope, close) {
        var modalInstance = $modal.open({
            templateUrl: templateUrl,
            scope: scope
        });
        modalInstance.result.then(close);
        return modalInstance;
    };
    /**
     * @ngdoc function 
     * @name home.controllers.MainController:maxZoomOut
     * @description Event launched from the leaflet directive. 
     * todo : It is not really a good practise to use broadcasting.
     * Maybe the scope.globalView could be modified inside the directive and the controller would watch it and add his behavior if needed.
     */
    $scope.$on("maxZoomOut", function(event, args) {
        $scope.$apply(function() {
            $scope.cameraPosition.latitude = args.position.lat;
            $scope.cameraPosition.longitude = args.position.lng;
            $scope.cameraPosition.radius = 5;
            $scope.globalView.type = "globe";
        });
    });
    $document.on("click", function() {
        angular.element(".tooltip[tooltip-popup]").remove();
    });
} ]);

/**
 * @ngdoc service
 * @name home.model.clusterProvider
 *
 * @description create groups inside arrays depending of the values
 * 
 */
angular.module("home").factory("clusterProvider", [ function($filter) {
    /**
         * @ngdoc function
         * @name home.model.clusterProvider:groupByOrder
         *
         * @description Group the cells of the array to form k-groups of n/k elements
         * the cells are taken in the array's order
         */
    this.groupByOrder = function(values, kGroup) {
        if (!values.length) return values;
        var length = values.length;
        if (length > kGroup) {
            var step = Math.round(length / kGroup);
            var groupArray = [];
            for (var i = 0; i < length; i += step) {
                var group = [];
                for (var j = i; j < i + step && j < length; j++) {
                    group.push(values[j]);
                }
                groupArray.push(group);
            }
            values = groupArray;
        }
        return values;
    };
    /**
         * @ngdoc function
         * @name home.model.clusterProvider:groupByValues
         *
         * @description Group the cells of the array to form k-groups
         * the cells are taken by values ranging [i, i + (max - min) / k] 
         */
    this.groupByValues = function(values, getValueDlg, kGroup, ordered, min, max) {
        if (!values.length) return values;
        if (values.length < kGroup && (min == undefined || max == undefined)) return values;
        if (min == undefined || max == undefined) {
            min = Infinity, max = -Infinity;
            for (var i in values) {
                min = Math.min(min, getValueDlg(values[i]));
                max = Math.max(max, getValueDlg(values[i]));
            }
        }
        var step = (max - min) / kGroup;
        var groupArray = [];
        //if the set is ordered we loop once in values instead of doing a filter looping more than once.
        if (ordered) {
            var j = 0;
            var oldJ = 0;
            for (var i = min; i < max; i += step) {
                while (j < values.length && getValueDlg(values[j]) < i + step) j++;
                var cluster = values.slice(oldJ, j);
                oldJ = j;
                cluster.min = i;
                cluster.max = i + step;
                groupArray.push(cluster);
            }
        } else {
            for (var i = min; i < max; i += step) {
                var cluster = values.filter(function(d) {
                    value = getValueDlg(d);
                    return value >= i && value < i + step;
                });
                cluster.min = i;
                cluster.max = i + step;
                groupArray.push(cluster);
            }
        }
        return groupArray;
    };
    /**
         * @ngdoc function
         * @name home.model.clusterProvider:groupByDistance
         *
         * @description Group the cells by a maximal distance given by the dirrecenceThresold
         * the function number distanceCB(elem A, elem B) has to be specified
         * the function weightedAverageCB is optional and compute a weighted average to replace the center of the cluster (if not it'll be the first point added to the cluster)
         */
    this.groupByDistance = function(values, differenceThresold, distanceCB, weightedAverageCB) {
        if (!values.length) return values;
        var length = values.length;
        var groups = [];
        var groupsMean = [];
        for (var i = 0; i < values.length; i++) {
            var minDistance = Infinity;
            var closerGroupIndex;
            for (var j = 0; j < groups.length; j++) {
                var currentDistance = distanceCB(groupsMean[j], values[i]);
                if (currentDistance < minDistance) {
                    minDistance = currentDistance;
                    closerGroupIndex = j;
                }
            }
            if (minDistance < differenceThresold) {
                if (weightedAverageCB) groupsMean[closerGroupIndex] = weightedAverageCB(groupsMean[closerGroupIndex], groups[closerGroupIndex].length, values[i], 1);
                groups[closerGroupIndex].push(values[i]);
            } else {
                groups.push([ values[i] ]);
                groupsMean.push(values[i]);
            }
        }
        return groups;
    };
    //accessors
    /**
         * @ngdoc function
         * @name home.model.clusterProvider:getSumValue
         *
         * @description return the sum of a cluster.
         */
    this.getSumValue = function(cluster, valueField) {
        if (!cluster.length) return cluster[valueField] ? cluster[valueField] : 0; else {
            var tmp = 0;
            cluster.forEach(function(value) {
                tmp += value[valueField];
            });
            return tmp;
        }
    };
    /**
         * @ngdoc function
         * @name home.model.clusterProvider:getAverageValue
         *
         * @description return the mean / Average of a cluster.
         */
    this.getAverageValue = function(cluster, valueField) {
        if (!cluster.length) return +cluster[valueField]; else return this.getSumValue(cluster, valueField) / cluster.length;
    };
    /**
         * @ngdoc function
         * @name home.model.clusterProvider:getFirstAndLastValue
         *
         * @description return the first and last value of a cluster.
         */
    this.getFirstAndLastValue = function(cluster, valueField, filterDlg) {
        filterDlg = filterDlg ? filterDlg : function(d) {
            return d;
        };
        if (!cluster.length) return filterDlg(cluster[valueField]); else if (cluster.length == 1) return filterDlg(cluster[0][valueField]); else return [ filterDlg(cluster[0][valueField]), filterDlg(cluster[cluster.length - 1][valueField]) ];
    };
    /**
         * @ngdoc function
         * @name home.model.clusterProvider:getMinAndMaxBoundary
         *
         * @description return the min and max value of a cluster.
         */
    this.getMinAndMaxBoundary = function(cluster, optField, filterDlg) {
        filterDlg = filterDlg ? filterDlg : function(d) {
            return d;
        };
        if (!cluster.min && !cluster.max) return filterDlg(cluster[optField]); else return [ filterDlg(cluster.min), filterDlg(cluster.max) ];
    };
    /**
         * @ngdoc function
         * @name home.model.clusterProvider:getModeValue
         *
         * @description return the mode or the value wich is more often present in a cluster.
         */
    this.getModeValue = function(cluster, valueField) {
        if (!cluster.length) return cluster[valueField]; else {
            var modeMap = {};
            var maxEl = cluster[0][valueField], maxCount = 0;
            for (var i = 0; i < cluster.length; i++) {
                var el = cluster[i][valueField];
                if (modeMap[el] == null) modeMap[el] = 1; else modeMap[el]++;
            }
            for (var i in modeMap) {
                if (modeMap[i] > maxCount) {
                    maxEl = i;
                    maxCount = modeMap[i];
                }
            }
            return maxEl;
        }
    };
    /**
         * @ngdoc function
         * @name home.model.clusterProvider:getMiddleValue
         *
         * @description return the middle value of a cluster.
         */
    this.getMiddleValue = function(cluster, valueField) {
        if (!cluster.length) return cluster[valueField]; else return cluster[Math.floor(cluster.length / 2)][valueField];
    };
    /**
         * @ngdoc function
         * @name home.model.clusterProvider:getLength
         *
         * @description return the number of elements of a cluster.
         */
    this.getLength = function(cluster) {
        if (!cluster.length) return 1; else {
            return cluster.length;
        }
    };
    return this;
} ]);

/**
 * @ngdoc service
 * @name home.model.colorProvider
 *
 * @description return a color associated with a Feature specific value. 
 * 
 */
angular.module("home").factory("colorProvider", [ "dataTypeEnum", function(dataTypeEnum) {
    try {
        var linear = d3.scale.linear().range([ "#e74c3c", "#f39c12", "#009871" ]).domain([ 0, .5, 1 ]);
        //TODO: only works with 11 different values
        //var ordinal = d3.scale.ordinal().range(["#fb8072", "#80b1d3", "#8dd3c7", "#ffffb3", "#bebada", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"]);
        var ordinal = d3.scale.category20b();
        // Ordinal scale used when few values
        var ordinalFewValues = d3.scale.category10();
        return function(value, type, size, domain) {
            // If there is few value
            if (type == dataTypeEnum.RANGE) {
                if (domain) linear.domain(domain); else linear.domain([ 0, .5, 1 ]);
                return linear(value);
            }
            if (size < 10) {
                return ordinalFewValues(value);
            } else {
                return ordinal(value);
            }
        };
    } catch (err) {
        console.log("load d3js to create color !");
        return function(value, type, size, domain) {
            return "#fff";
        };
    }
} ]);

/**
 * @ngdoc service
 * @name home.model.dataAccessProvider
 *
 * @description Load csv data with the angular.$http service and convert it to js with d3.csv function.
 * 
 */
angular.module("home").factory("dataAccessProvider", [ "$http", "$rootScope", function($http, $rootScope) {
    return {
        csv: function(csvPath, callBackGet, callBackError) {
            d3.csv(csvPath).get(function(error, rows) {
                $rootScope.$apply(function() {
                    if (error) callBackError(error); else if (rows) callBackGet(rows);
                });
            });
        },
        json: function(json, callBackGet, callBackError) {
            d3.json(json).get(function(error, rows) {
                $rootScope.$apply(function() {
                    if (error) callBackError(error); else if (rows) callBackGet(rows);
                });
            });
        }
    };
} ]);

angular.module("home").directive("fileread", [ function() {
    return {
        scope: {
            fileread: "=?",
            filename: "=?",
            fileFormat: "=?"
        },
        link: function(scope, element, attributes) {
            element.bind("change", function(changeEvent) {
                if (scope.fileread !== undefined) {
                    var reader = new FileReader();
                    reader.onload = function(loadEvent) {
                        scope.$apply(function() {
                            if (scope.fileFormat == "csv") scope.fileread = d3.csv.parse(loadEvent.target.result); else if (scope.fileFormat == "json") scope.fileread = d3.json.parse(loadEvent.target.result); else scope.fileread = loadEvent.target.result;
                        });
                    };
                    reader.readAsText(changeEvent.target.files[0]);
                }
                if (scope.filename !== undefined) {
                    scope.$apply(function() {
                        scope.filename = changeEvent.target.files[0];
                    });
                }
            });
            scope.$on("$destroy", function() {
                element.off("change");
            });
        }
    };
} ]);

/**
 * @ngdoc service
 * @name Home.model.filterProvider
 * @description service filtering the data.
 * the conditions and the filtering behavior are overridable. By default it is compliant with the home.controllers.FormController.Where class.
 *
 * you can retreive all the filtered data with the getResult function accross all the app. it'll compute only once the filtering, lazily.
 * Thus, you'll have to instantiate the service to filter on more than one data object.
 *
 * @requires home.controllers.FormController.Where
 */
angular.module("home").factory("filterProvider", function() {
    var _data = [];
    var _conditions = [];
    var _result = [];
    var _modified = true;
    function _filter(input, conditions) {
        for (var i in conditions) {
            var condition = conditions[i];
            if (!condition.feature) continue;
            //todo : use of strictly equal to differentiate between 0 and undefined
            if (condition.minValue !== undefined && condition.minValue !== null && input[condition.feature.name] < condition.minValue) return false;
            if (condition.maxValue !== undefined && condition.maxValue !== null && input[condition.feature.name] > condition.maxValue) return false;
            if (condition.value !== undefined && condition.value !== null && input[condition.feature.name] != condition.value) return false;
        }
        return true;
    }
    /**
     * @ngdoc function
     * @name Home.model.filterProvider:setData
     * @description set the data to filter
     *
     */
    this.setData = function(data) {
        _data = data;
        this.isChanged(true);
    };
    this.getData = function() {
        return _data;
    };
    /**
     * @ngdoc function
     * @name Home.model.filterProvider:setConditions
     * @description set the conditions array which is send 
     *
     */
    this.getConditions = function() {
        return _conditions;
    };
    this.setConditions = function(conditions) {
        _conditions = conditions;
        this.isChanged(true);
    };
    this.setFilter = function(filter) {
        _filter = filter;
        this.isChanged(true);
    };
    this.isChanged = function(value) {
        if (angular.isDefined(value)) _modified = value;
        return _modified;
    };
    /**
     * @ngdoc function
     * @name Home.model.filterProvider:getResult
     * @description return the filtered data. 
     * dD the computation only when needed.
     */
    this.getResult = function() {
        if (this.isChanged()) {
            _result = _data.filter(function(input) {
                return _filter(input, _conditions);
            });
            this.isChanged(false);
        }
        return _result;
    };
    return this;
});

/**
 * @ngdoc service
 * @name Home.model.legendProvider
 * @description service representing the columns in the data.
 * it takes raw data and instantiate a List of Features object to
 * compute some statistics.
 *
 * @requires home.model.legendProvider.Feature
 */
angular.module("home").factory("legendProvider", [ "dataTypeEnum", "dataFeaturesEnum", "colorProvider", function featuresFactory(dataTypeEnum, dataFeaturesEnum, colorProvider) {
    var that = this;
    /**
     * @ngdoc function
     * @name home.model.legendProvider.Feature
     * @description Feature Class which compute all the statistics, a distinct ordonned array of the values and so on.
     *
     * @requires home.model.dataFeaturesEnum
     * @requires home.model.dataTypeEnum
     * @requires home.model.colorProvider
     * @requires home.model.legendProvider.DistinctValue
     */
    this.Feature = function(metaData, values) {
        //DistinctValue class to expose an interface
        /**
         * @ngdoc function
         * @name home.model.legendProvider.DistinctValue
         * @description DistinctValue class to expose an interface
         *
         */
        var DistinctValue = function(value, support, color, valueNormalized, supportNormalized) {
            this.value = value;
            this.support = support;
            this.valueNormalized = valueNormalized;
            this.supportNormalized = supportNormalized;
            this.color = color;
        };
        this.name = metaData.name;
        this.alias = metaData.alias;
        this.description = metaData.description;
        this.type = metaData.type;
        this.unit = metaData.unit;
        this.values;
        this.minValue;
        this.maxValue;
        this.average;
        this.quartile1;
        this.mean;
        this.quartile3;
        this.distinctValues;
        this.minSupport;
        this.maxSupport;
        this.distinctValuesArray;
        this.normalise = function(value, min, max) {
            if (isNaN(value)) return value;
            var result = (value - min) / (max - min);
            if (isNaN(result)) result = 0;
            return result;
        };
        this.setValues = function(values) {
            //Values = sorted array of primitive with duplicate
            switch (this.type) {
              case dataTypeEnum.DISCRET:
              case dataTypeEnum.BOOL:
              case dataTypeEnum.ID:
                values.sort();
                break;

              case dataTypeEnum.DATE:
              case dataTypeEnum.RANGE:
                values.sort(function(a, b) {
                    return +a - +b;
                });
                //todo: slow to cast string to integer each time ?
                break;
            }
            this.values = values;
            //TODO unsafe range
            this.getPercentile = function(percentile) {
                var i = (this.values.length - 1) * percentile;
                if (i % 1 == 0) {
                    //check if integer or decimal  
                    return this.values[i];
                } else {
                    i = Math.floor(i);
                    return (+this.values[i] + +this.values[i + 1]) / 2;
                }
            };
            //todo: refactoring the class to call this method:
            this.createValue = function(value) {
                var valueNormalized = this.normalise(value, this.minValue, this.maxValue);
                return new DistinctValue(value, 1, colorProvider(valueNormalized, this.type, 0, [ this.quartile1Norm, this.meanNorm, this.quartile3Norm ]), valueNormalized, 1);
            };
            this.minValue = this.getPercentile(0);
            this.maxValue = this.getPercentile(1);
            var _average;
            this.getAverage = function() {
                if (_average === undefined) {
                    _average = 0;
                    for (var i in this.values) _average += this.values[i];
                    _average /= this.values.length;
                }
                return _average;
            };
            this.quartile1 = this.getPercentile(.25);
            this.quartile1Norm = this.normalise(this.quartile1, this.minValue, this.maxValue);
            this.mean = this.getPercentile(.5);
            this.meanNorm = this.normalise(this.mean, this.minValue, this.maxValue);
            this.quartile3 = this.getPercentile(.75);
            this.quartile3Norm = this.normalise(this.quartile3, this.minValue, this.maxValue);
            //DistinctValues = dictionary of DistinctValues : {value :{value, support, color}, value : {value, support, color}}
            var _distinctValues;
            this.getDistinctValues = function() {
                if (_distinctValues === undefined) {
                    _distinctValues = {};
                    for (var i in this.values) {
                        value = this.values[i];
                        if (!_distinctValues[value]) _distinctValues[value] = new DistinctValue(value, 1, null); else _distinctValues[value].support++;
                    }
                    var count = 0;
                    var totalDistinctValue = 0;
                    for (var j in _distinctValues) {
                        if (totalDistinctValue > 15) {
                            break;
                        }
                        totalDistinctValue++;
                    }
                    for (var i in _distinctValues) {
                        _distinctValues[i].valueNormalized = this.normalise(_distinctValues[i].value, this.minValue, this.maxValue);
                        _distinctValues[i].supportNormalized = this.normalise(_distinctValues[i].support, this.minSupport, this.maxSupport);
                        if (this.type == "DISCRET" || this.type == "BOOL" || this.type == "ID") _distinctValues[i].color = colorProvider(count, this.type, totalDistinctValue); else _distinctValues[i].color = colorProvider(_distinctValues[i].valueNormalized, this.type, totalDistinctValue, [ this.quartile1Norm, this.meanNorm, this.quartile3Norm ]);
                        count++;
                    }
                }
                return _distinctValues;
            };
            var _minSupport;
            this.getMinSupport = function() {
                if (_minSupport === undefined) {
                    _minSupport = Infinity;
                    for (var i in this.getDistinctValues()) {
                        _minSupport = Math.min(this.getDistinctValues()[i].support, _minSupport);
                    }
                }
                return _minSupport;
            };
            var _maxSupport;
            this.getMaxSupport = function() {
                if (!_maxSupport === undefined) {
                    _maxSupport = -Infinity;
                    for (var i in this.getDistinctValues()) {
                        _maxSupport = Math.max(this.getDistinctValues()[i].support, _maxSupport);
                    }
                }
                return _maxSupport;
            };
            //DistinctValuesArray = Distinct, unsorted, array of Values: [{value, support, color}, {value, support, color}] 
            var _distinctValuesArray;
            this.getDistinctValuesArray = function() {
                if (_distinctValuesArray === undefined) {
                    _distinctValuesArray = [];
                    var distinctValues = this.getDistinctValues();
                    for (var i in distinctValues) {
                        _distinctValuesArray.push(distinctValues[i]);
                    }
                }
                return _distinctValuesArray;
            };
        };
        if (values != undefined) {
            this.setValues(values);
        }
    };
    this.getColumn = function(array, columnName) {
        var result = [];
        array.forEach(function(value) {
            result.push(value[columnName]);
        });
        return result;
    };
    this.parseDate = function(dateStr) {
        try {
            if (!dateStr || dateStr == "NA") return;
            var a = dateStr.split(" ");
            var d = a[0].split("-");
            var t = a[1].split(":");
            //I choose to let the local time which as more meaning instead of the Greenwich mean time
            return new Date(d[0], d[1] - 1, d[2], t[0], t[1]);
        } catch (err) {
            console.error("the dateStr is not valide : " + dateStr);
        }
    };
    this.parse = function(String, type) {
        var value;
        switch (type) {
          case dataTypeEnum.DISCRET:
          case dataTypeEnum.BOOL:
          case dataTypeEnum.ID:
            value = String;
            break;

          case dataTypeEnum.DATE:
            value = this.parseDate(String);
            break;

          case dataTypeEnum.RANGE:
            value = +String;
            break;
        }
        return value;
    };
    /**
     * @ngdoc function
     * @name home.model.legendProvider:parseData
     * @description call this method to parse all the string data into a String, date, or numeral; depending on the metaData. 
     *
     */
    this.parseData = function(data, metaData) {
        data.forEach(function(row) {
            for (var i in row) {
                row[i] = that.parse(row[i], metaData[i].type);
            }
        });
        return data;
    };
    //TODO method too specific ?
    this.getLegend = function(data, feature) {
        if (feature) {
            var values = this.getColumn(data, feature.name);
            return new this.Feature(feature, values);
        }
        tmp = {};
        for (var i in data[0]) {
            var meta = dataFeaturesEnum[i];
            var values = this.getColumn(data, meta.name);
            tmp[meta.name] = new this.Feature(meta, values);
        }
        return tmp;
    };
    this.normalize = function(value, min, max) {
        if (isNaN(value)) return value;
        var result = (value - min) / (max - min);
        if (isNaN(result)) result = 0;
        return result;
    };
    /**
    * @ngdoc function
    * @name home.model.legendProvider:computeLabels
    * @description call this method to return a columns and rows dictionary :
    *   {
            rows: {
                featureRow0: normalizeFn,
                featureRow1: normalizeFn
            },
            columns: {
                featureColumn0 : normalizeFn,
                featureColumn1: normalizeFn
            }
        }
    *
    */
    this.computeLabels = function(matrix) {
        var columns = {};
        var rows = {};
        for (var row in matrix) {
            rows[row] = {};
            for (var column in matrix[row]) {
                columns[column] = {};
            }
        }
        for (var row in rows) {
            var minValue = Infinity;
            for (var i in matrix[row]) {
                minValue = Math.min(matrix[row][i], minValue);
            }
            var maxValue = -Infinity;
            for (var i in matrix[row]) {
                maxValue = Math.max(matrix[row][i], maxValue);
            }
            rows[row] = {
                minValue: minValue,
                maxValue: maxValue
            };
        }
        for (var column in columns) {
            var minValue = Infinity;
            var maxValue = -Infinity;
            for (var row in rows) {
                minValue = Math.min(matrix[row][column], minValue);
                maxValue = Math.max(matrix[row][column], maxValue);
            }
            columns[column] = {
                minValue: minValue,
                maxValue: maxValue
            };
        }
        return {
            columns: columns,
            rows: rows
        };
    };
    return this;
} ]);

/**
 * @ngdoc value
 * @name home.model.dataTypeEnum
 * @description enumerator of the data types supported by the application
 */
angular.module("home").value("dataTypeEnum", {
    DISCRET: "DISCRET",
    //values with duplication like Iphone4, Iphone5
    RANGE: "RANGE",
    //numerical values
    DATE: "DATE",
    //date value
    ID: "ID",
    //ID values (not unique) like "henri", "alfred"
    BOOL: "BOOL"
});

/**
 * @ngdoc service
 * @name home.model.dataFeaturesEnum
 * @description enumerator of the features (column) in the data.
 * a feature contains a type, description, alias, name and unit
 *
 * TODO: Add the visibility of the feature (visible : true/false) ?
 * @requires home.model.dataTypeEnum
 */
angular.module("home").factory("dataFeaturesEnum", [ "dataTypeEnum", function featuresFactory(dataTypeEnum) {
    return {
        tag: {
            type: "ID",
            description: "          ",
            alias: "tag",
            name: "tag",
            unit: "",
            redondant: true
        },
        uid: {
            type: "ID",
            description: "          ",
            alias: "uid",
            name: "uid",
            unit: "",
            redondant: true
        },
        uuid: {
            type: "ID",
            description: "          ",
            alias: "uuid",
            name: "uuid",
            unit: "",
            redondant: true
        },
        client_id: {
            type: "ID",
            description: "          ",
            alias: "client id",
            name: "client_id",
            unit: "",
            redondant: true
        },
        client_version: {
            type: "DISCRET",
            description: "          ",
            alias: "client version",
            name: "client_version",
            unit: "",
            redondant: true
        },
        client_name: {
            type: "DISCRET",
            description: "          ",
            alias: "client name",
            name: "client_name",
            unit: "",
            redondant: true
        },
        client_language: {
            type: "DISCRET",
            description: "          ",
            alias: "client language",
            name: "client_language",
            unit: "",
            redondant: true
        },
        client_local_ip: {
            type: "ID",
            description: "          ",
            alias: "client local ip",
            name: "client_local_ip",
            unit: "",
            redondant: true
        },
        token: {
            type: "ID",
            description: "          ",
            alias: "token",
            name: "token",
            unit: "",
            redondant: true
        },
        server_id: {
            type: "DISCRET",
            description: "          ",
            alias: "server id",
            name: "server_id",
            unit: "",
            redondant: true
        },
        port: {
            type: "DISCRET",
            description: "          ",
            alias: "port",
            name: "port",
            unit: "",
            redondant: false
        },
        use_ssl: {
            type: "BOOL",
            description: "          ",
            alias: "use ssl",
            name: "use_ssl",
            unit: "",
            redondant: true
        },
        time: {
            type: "DATE",
            description: "          ",
            alias: "time",
            name: "time",
            unit: "",
            redondant: false
        },
        speed_upload: {
            type: "RANGE",
            description: "          ",
            alias: "speed upload",
            name: "speed_upload",
            unit: "bps",
            redondant: false
        },
        speed_download: {
            type: "RANGE",
            description: "          ",
            alias: "speed download",
            name: "speed_download",
            unit: "bps",
            redondant: false
        },
        ping_shortest: {
            type: "RANGE",
            description: "          ",
            alias: "ping shortest",
            name: "ping_shortest",
            unit: "NA",
            redondant: true
        },
        encryption: {
            type: "DISCRET",
            description: "          ",
            alias: "encryption",
            name: "encryption",
            unit: "",
            redondant: true
        },
        client_public_ip: {
            type: "ID",
            description: "          ",
            alias: "client public ip",
            name: "client_public_ip",
            unit: "",
            redondant: true
        },
        plattform: {
            type: "DISCRET",
            description: "          ",
            alias: "plattform",
            name: "plattform",
            unit: "",
            redondant: false
        },
        os_version: {
            type: "DISCRET",
            description: "          ",
            alias: "os version",
            name: "os_version",
            unit: "",
            redondant: false
        },
        api_level: {
            type: "DISCRET",
            description: "          ",
            alias: "api level",
            name: "api_level",
            unit: "",
            redondant: true
        },
        device: {
            type: "DISCRET",
            description: "          ",
            alias: "device",
            name: "device",
            unit: "",
            redondant: false
        },
        model: {
            type: "DISCRET",
            description: "          ",
            alias: "model",
            name: "model",
            unit: "",
            redondant: false
        },
        product: {
            type: "DISCRET",
            description: "          ",
            alias: "product",
            name: "product",
            unit: "",
            redondant: false
        },
        phone_type: {
            type: "DISCRET",
            description: "          ",
            alias: "phone type",
            name: "phone_type",
            unit: "",
            redondant: true
        },
        data_state: {
            type: "DISCRET",
            description: "          ",
            alias: "data state",
            name: "data_state",
            unit: "",
            redondant: true
        },
        network_country: {
            type: "DISCRET",
            description: "          ",
            alias: "network country",
            name: "network_country",
            unit: "",
            redondant: false
        },
        network_operator: {
            type: "DISCRET",
            description: "          ",
            alias: "network operator",
            name: "network_operator",
            unit: "",
            redondant: true
        },
        network_operator_name: {
            type: "DISCRET",
            description: "          ",
            alias: "network operator name",
            name: "network_operator_name",
            unit: "",
            redondant: false
        },
        network_sim_country: {
            type: "DISCRET",
            description: "          ",
            alias: "network sim country",
            name: "network_sim_country",
            unit: "",
            redondant: true
        },
        network_sim_operator: {
            type: "DISCRET",
            description: "          ",
            alias: "network sim operator",
            name: "network_sim_operator",
            unit: "",
            redondant: true
        },
        network_sim_operator_name: {
            type: "DISCRET",
            description: "          ",
            alias: "network sim operator name",
            name: "network_sim_operator_name",
            unit: "",
            redondant: true
        },
        duration: {
            type: "DISCRET",
            description: "          ",
            alias: "duration",
            name: "duration",
            unit: "",
            redondant: true
        },
        num_threads: {
            type: "DISCRET",
            description: "          ",
            alias: "num threads",
            name: "num_threads",
            unit: "",
            redondant: true
        },
        status: {
            type: "BOOL",
            description: "          ",
            alias: "status",
            name: "status",
            unit: "",
            redondant: true
        },
        timezone: {
            type: "DISCRET",
            description: "          ",
            alias: "timezone",
            name: "timezone",
            unit: "",
            redondant: true
        },
        bytes_upload: {
            type: "RANGE",
            description: "          ",
            alias: "bytes upload",
            name: "bytes_upload",
            unit: "Bytes",
            redondant: true
        },
        nsec_download: {
            type: "RANGE",
            description: "          ",
            alias: "nsec download",
            name: "nsec_download",
            unit: "Seconds",
            redondant: true
        },
        nsec_upload: {
            type: "RANGE",
            description: "          ",
            alias: "nsec upload",
            name: "nsec_upload",
            unit: "Seconds",
            redondant: true
        },
        server_ip: {
            type: "ID",
            description: "          ",
            alias: "server ip",
            name: "server_ip",
            unit: "",
            redondant: true
        },
        client_software_version: {
            type: "DISCRET",
            description: "       ",
            alias: "client software version",
            name: "client_software_version",
            unit: "",
            redondant: true
        },
        geo_lat: {
            type: "RANGE",
            description: "          ",
            alias: "geo lat",
            name: "geo_lat",
            unit: "degree",
            redondant: false
        },
        geo_long: {
            type: "RANGE",
            description: "          ",
            alias: "geo long",
            name: "geo_long",
            unit: "degree",
            redondant: false
        },
        network_type: {
            type: "DISCRET",
            description: "          ",
            alias: "network type",
            name: "network_type",
            unit: "",
            redondant: true
        },
        location: {
            type: "ID",
            description: "          ",
            alias: "location",
            name: "location",
            unit: "",
            redondant: true
        },
        signal_strength: {
            type: "RANGE",
            description: "          ",
            alias: "signal strength",
            name: "signal_strength",
            unit: "decibels",
            redondant: true
        },
        software_revision: {
            type: "DISCRET",
            description: "          ",
            alias: "software revision",
            name: "software_revision",
            unit: "",
            redondant: true
        },
        client_test_counter: {
            type: "RANGE",
            description: "          ",
            alias: "client test counter",
            name: "client_test_counter",
            unit: "",
            redondant: true
        },
        nat_type: {
            type: "DISCRET",
            description: "          ",
            alias: "nat type",
            name: "nat_type",
            unit: "",
            redondant: true
        },
        client_previous_test_status: {
            type: "DISCRET",
            description: "          ",
            alias: "client previous test status",
            name: "client_previous_test_status",
            unit: "",
            redondant: true
        },
        public_ip_asn: {
            type: "DISCRET",
            description: "          ",
            alias: "public ip asn",
            name: "public_ip_asn",
            unit: "",
            redondant: true
        },
        speed_upload_log: {
            type: "RANGE",
            description: "          ",
            alias: "speed upload log",
            name: "speed_upload_log",
            unit: "",
            redondant: true
        },
        speed_download_log: {
            type: "RANGE",
            description: "          ",
            alias: "speed download log",
            name: "speed_download_log",
            unit: "",
            redondant: true
        },
        total_bytes_download: {
            type: "RANGE",
            description: "          ",
            alias: "total bytes download",
            name: "total_bytes_download",
            unit: "Bytes",
            redondant: true
        },
        total_bytes_upload: {
            type: "RANGE",
            description: "          ",
            alias: "total bytes upload",
            name: "total_bytes_upload",
            unit: "Bytes",
            redondant: true
        },
        public_ip_rdns: {
            type: "ID",
            description: "          ",
            alias: "public ip rdns",
            name: "public_ip_rdns",
            unit: "",
            redondant: true
        },
        public_ip_as_name: {
            type: "DISCRET",
            description: "          ",
            alias: "public ip as name",
            name: "public_ip_as_name",
            unit: "",
            redondant: true
        },
        test_slot: {
            type: "ID",
            description: "          ",
            alias: "test slot",
            name: "test_slot",
            unit: "",
            redondant: true
        },
        provider_id: {
            type: "ID",
            description: "          ",
            alias: "provider id",
            name: "provider_id",
            unit: "",
            redondant: true
        },
        network_is_roaming: {
            type: "BOOL",
            description: "          ",
            alias: "network is roaming",
            name: "network_is_roaming",
            unit: "",
            redondant: true
        },
        ping_shortest_log: {
            type: "RANGE",
            description: "          ",
            alias: "ping shortest log",
            name: "ping_shortest_log",
            unit: "",
            redondant: true
        },
        run_ndt: {
            type: "BOOL",
            description: "          ",
            alias: "run ndt",
            name: "run_ndt",
            unit: "",
            redondant: true
        },
        num_threads_requested: {
            type: "DISCRET",
            description: "          ",
            alias: "num threads requested",
            name: "num_threads_requested",
            unit: "",
            redondant: true
        },
        client_public_ip_anonymized: {
            type: "ID",
            description: "          ",
            alias: "client public ip anonymized",
            name: "client_public_ip_anonymized",
            unit: "",
            redondant: true
        },
        geo_provider: {
            type: "DISCRET",
            description: "          ",
            alias: "geo provider",
            name: "geo_provider",
            unit: "",
            redondant: true
        },
        geo_accuracy: {
            type: "RANGE",
            description: "          ",
            alias: "geo accuracy",
            name: "geo_accuracy",
            unit: "meter",
            redondant: true
        },
        deleted: {
            type: "BOOL",
            description: "          ",
            alias: "deleted",
            name: "deleted",
            unit: "",
            redondant: true
        },
        open_uuid: {
            type: "ID",
            description: "          ",
            alias: "open uuid",
            name: "open_uuid",
            unit: "",
            redondant: true
        },
        client_time: {
            type: "DATE",
            description: "          ",
            alias: "client time",
            name: "client_time",
            unit: "",
            redondant: true
        },
        mobile_provider_id: {
            type: "ID",
            description: "          ",
            alias: "mobile provider id",
            name: "mobile_provider_id",
            unit: "",
            redondant: true
        },
        roaming_type: {
            type: "DISCRET",
            description: "          ",
            alias: "roaming type",
            name: "roaming_type",
            unit: "",
            redondant: true
        },
        open_test_uuid: {
            type: "ID",
            description: "          ",
            alias: "open test uuid",
            name: "open_test_uuid",
            unit: "",
            redondant: true
        },
        country_asn: {
            type: "DISCRET",
            description: "          ",
            alias: "country asn",
            name: "country_asn",
            unit: "",
            redondant: true
        },
        country_location: {
            type: "DISCRET",
            description: "          ",
            alias: "country location",
            name: "country_location",
            unit: "",
            redondant: true
        },
        test_if_bytes_download: {
            type: "RANGE",
            description: "          ",
            alias: "test if bytes download",
            name: "test_if_bytes_download",
            unit: "",
            redondant: true
        },
        test_if_bytes_upload: {
            type: "RANGE",
            description: "          ",
            alias: "test if bytes upload",
            name: "test_if_bytes_upload",
            unit: "",
            redondant: true
        },
        implausible: {
            type: "BOOL",
            description: "          ",
            alias: "implausible",
            name: "implausible",
            unit: "",
            redondant: true
        },
        testdl_if_bytes_download: {
            type: "RANGE",
            description: "          ",
            alias: "testdl if bytes download",
            name: "testdl_if_bytes_download",
            unit: "",
            redondant: true
        },
        testdl_if_bytes_upload: {
            type: "RANGE",
            description: "          ",
            alias: "testdl if bytes upload",
            name: "testdl_if_bytes_upload",
            unit: "",
            redondant: true
        },
        testul_if_bytes_download: {
            type: "RANGE",
            description: "          ",
            alias: "testul if bytes download",
            name: "testul_if_bytes_download",
            unit: "",
            redondant: true
        },
        testul_if_bytes_upload: {
            type: "RANGE",
            description: "          ",
            alias: "testul if bytes upload",
            name: "testul_if_bytes_upload",
            unit: "",
            redondant: true
        },
        country_geoip: {
            type: "DISCRET",
            description: "          ",
            alias: "country geoip",
            name: "country_geoip",
            unit: "",
            redondant: true
        },
        network_group_name: {
            type: "DISCRET",
            description: "          ",
            alias: "network group name",
            name: "network_group_name",
            unit: "",
            redondant: false
        },
        network_group_type: {
            type: "DISCRET",
            description: "          ",
            alias: "network group type",
            name: "network_group_type",
            unit: "",
            redondant: true
        },
        timestamp: {
            type: "DATE",
            description: "          ",
            alias: "timestamp",
            name: "timestamp",
            unit: "milliseconds",
            redondant: true
        },
        source_ip: {
            type: "ID",
            description: "          ",
            alias: "source ip",
            name: "source_ip",
            unit: "",
            redondant: true
        },
        lte_rsrp: {
            type: "RANGE",
            description: "          ",
            alias: "lte rsrp",
            name: "lte_rsrp",
            unit: "",
            redondant: true
        },
        lte_rsrq: {
            type: "RANGE",
            description: "          ",
            alias: "lte rsrq",
            name: "lte_rsrq",
            unit: "",
            redondant: true
        },
        "network_type.name": {
            type: "DISCRET",
            description: "          ",
            alias: "network type.name",
            name: "network_type.name",
            unit: "",
            redondant: true
        },
        "network_type.group_name": {
            type: "DISCRET",
            description: "          ",
            alias: "network type.group name",
            name: "network_type.group_name",
            unit: "",
            redondant: true
        },
        "network_type.aggregate": {
            type: "DISCRET",
            description: "          ",
            alias: "network type.aggregate",
            name: "network_type.aggregate",
            unit: "",
            redondant: true
        },
        "network_type.type": {
            type: "DISCRET",
            description: "          ",
            alias: "network type.type",
            name: "network_type.type",
            unit: "",
            redondant: true
        },
        "network_type.technology_order": {
            type: "DISCRET",
            description: "          ",
            alias: "network type.technology order",
            name: "network_type.technology_order",
            unit: "",
            redondant: true
        },
        time_year: {
            type: "RANGE",
            description: "The year of the transaction",
            alias: "time year",
            name: "time_year",
            unit: "Years",
            redondant: true
        },
        time_month: {
            type: "RANGE",
            description: "The month of the transaction",
            alias: "time month",
            name: "time_month",
            unit: "Months",
            redondant: true
        },
        time_mday: {
            type: "RANGE",
            description: "The day of the month of the transaction",
            alias: "time mday",
            name: "time_mday",
            unit: "Days",
            redondant: true
        },
        time_wday: {
            type: "RANGE",
            description: "The day of the week of the transaction",
            alias: "time wday",
            name: "time_wday",
            unit: "Days",
            redondant: true
        },
        time_yday: {
            type: "RANGE",
            description: "The day of the year of the transaction",
            alias: "time yday",
            name: "time_yday",
            unit: "Days",
            redondant: true
        },
        time_hour: {
            type: "RANGE",
            description: "The hour of the transaction",
            alias: "time hour",
            name: "time_hour",
            unit: "Hours",
            redondant: true
        },
        time_minute: {
            type: "RANGE",
            description: "The minute of the transaction",
            alias: "time minute",
            name: "time_minute",
            unit: "Minutes",
            redondant: true
        },
        house_number: {
            type: "DISCRET",
            description: "The house number of the location",
            alias: "house number",
            name: "house_number",
            unit: "",
            redondant: true
        },
        road: {
            type: "DISCRET",
            description: "The road name of the location",
            alias: "road",
            name: "road",
            unit: "",
            redondant: true
        },
        suburb: {
            type: "DISCRET",
            description: "The suburb name of the location",
            alias: "suburb",
            name: "suburb",
            unit: "",
            redondant: true
        },
        city_district: {
            type: "DISCRET",
            description: "The district name of the location",
            alias: "city district",
            name: "city_district",
            unit: "",
            redondant: true
        },
        city: {
            type: "DISCRET",
            description: "The city name of the location",
            alias: "city",
            name: "city",
            unit: "",
            redondant: true
        },
        county: {
            type: "DISCRET",
            description: "The county name of the location",
            alias: "county",
            name: "county",
            unit: "",
            redondant: false
        },
        state: {
            type: "DISCRET",
            description: "The state name of the location",
            alias: "state",
            name: "state",
            unit: "",
            redondant: true
        },
        country: {
            type: "DISCRET",
            description: "The country name of the location",
            alias: "country",
            name: "country",
            unit: "",
            redondant: true
        },
        town: {
            type: "DISCRET",
            description: "The town name of the location",
            alias: "town",
            name: "town",
            unit: "",
            redondant: true
        },
        postcode: {
            type: "DISCRET",
            description: "The postcode of the location",
            alias: "postcode",
            name: "postcode",
            unit: "",
            redondant: true
        },
        cluster_index: {
            type: "DISCRET",
            description: "The cluster of the sample",
            alias: "cluster index",
            name: "cluster_index",
            unit: "",
            redondant: true
        }
    };
} ]);

angular.module("home").directive("clusterEntryDirective", [ "legendProvider", function(legendProvider) {
    function link(scope, element, attrs) {
        scope.isCollapsed = true;
        scope.$watch("cluster", function(value) {
            if (value) {
                scope.speedDownloadLegend = new legendProvider.Feature({
                    type: "RANGE"
                }, legendProvider.getColumn(value, "speed_download")).distinctValuesArray;
                scope.speedUploadLegend = new legendProvider.Feature({
                    type: "RANGE"
                }, legendProvider.getColumn(value, "speed_upload")).distinctValuesArray;
            }
        });
    }
    return {
        restrict: "E",
        scope: {
            cluster: "="
        },
        templateUrl: function(elem, attrs) {
            if (attrs.detailed == "true") return "app/components/home/views/clusterEntry/clusterEntryLong.html"; else return "app/components/home/views/clusterEntry/clusterEntry.html";
        },
        link: link
    };
} ]);

/**
 * @ngdoc directive
 * @name home.views.entryDirective
 * @description Display some fields of a data entry.
 *
 */
angular.module("home").directive("entryDirective", [ "clusterProvider", function(clusterProvider) {
    function link(scope, element, attrs) {
        scope.isCollapsed = true;
        scope.$watch("entry", function() {
            if (scope.entry && scope.isCluster && scope.entry.length) {
                var result = {};
                for (key in scope.entry[0]) {
                    result[key] = clusterProvider.getFirstAndLastValue(scope.entry, key);
                }
                scope.entry = result;
            }
        });
    }
    return {
        restrict: "E",
        scope: {
            entry: "=",
            isCluster: "="
        },
        templateUrl: function(elem, attrs) {
            if (attrs.detailed == "true") return "app/components/home/views/entry/entryLong.html"; else return "app/components/home/views/entry/entry.html";
        },
        link: link
    };
} ]);

/**
 * @ngdoc directive
 * @name home.views.formDirective
 * @description Display a form to select and filter data.
 *
 * @requires home.controller.FormController
 */
angular.module("home").directive("formDirective", [ "$timeout", function($timeout) {
    function link(scope, element, attrs) {
        scope.date = {};
        scope.open = function($event, field) {
            $event.preventDefault();
            $event.stopPropagation();
            scope.date[field] = true;
        };
        scope.dateOptions = {
            formatYear: "yy",
            startingDay: 1
        };
        scope.dirtyUpdate = scope.dirtyUpdate ? scope.dirtyUpdate + 1 : 1;
    }
    return {
        restrict: "E",
        templateUrl: "app/components/home/views/form/formPartial.html",
        link: link
    };
} ]);

/**
 * @ngdoc directive
 * @name home.views.globeDirective
 * @description display a 3D globe with markers 
 *
 * @requires graphs.views.barChartDirective
 * @requires graphs.views.tooltipDirective
 * @requires home.model.clusterProvider
 */
angular.module("home").directive("globeDirective", [ "clusterProvider", "legendProvider", function(clusterProvider, legendProvider) {
    function link(scope, element, attrs) {
        var container = element[0];
        //todo: when inside element, the svg is not well placed
        var width = function() {
            return element.parent().width() || window.innerWidth;
        };
        var height = function() {
            return element.parent().height() || window.innerHeight;
        };
        var globeTexture = scope.globeTexture || "data/assets/world.jpg";
        var backgroundTexture = scope.backgroundTexture || "data/assets/tiled_bg_stars.jpg";
        var globe = new Globe(container, width(), height(), scope.cameraPosition, function() {
            scope.$apply(function() {
                console.log("minRadius");
                scope.globalView.type = "map";
            });
        }, globeTexture, backgroundTexture);
        ///eventListeners
        //function onDataChanged(value) {
        //    var clusters = clusterProvider.groupByDistance(value, 0.5, function (a, b) {
        //        var dx = a.geo_lat - b.geo_lat,
        //        dy = a.geo_long - b.geo_long;
        //        return Math.sqrt(dx * dx + dy * dy);
        //    });
        //    globe.CreatePoints(clusters, function (e) { return clusterProvider.getMiddleValue(e, 'geo_lat'); }, function (e) { return clusterProvider.getMiddleValue(e, 'geo_long'); });
        //};
        //function onLegendChanged(value) {
        //    if (value.length == 0)
        //        return
        //    globe.UpdatePointsValue(scope.data.values, scope.data.legend);
        //    scope.globalView.ready = true;
        //}
        function update() {
            var clusters = clusterProvider.groupByDistance(scope.values, .2, function(a, b) {
                var dx = a.geo_lat - b.geo_lat, dy = a.geo_long - b.geo_long;
                return Math.sqrt(dx * dx + dy * dy);
            }, function(A, wA, B, wB) {
                A.geo_lat = (A.geo_lat * wA + B.geo_lat * wB) / (wA + wB);
                A.geo_long = (A.geo_long * wA + B.geo_long * wB) / (wA + wB);
                return A;
            });
            globe.Update(clusters, function(e) {
                return clusterProvider.getMiddleValue(e, "geo_lat");
            }, function(e) {
                return clusterProvider.getMiddleValue(e, "geo_long");
            }, function(e) {
                if (scope.legend.type == "RANGE") return scope.legend.createValue(clusterProvider.getAverageValue(e, scope.legend.name)); else return scope.legend.getDistinctValues()[clusterProvider.getModeValue(e, scope.legend.name)];
            }, scope.legend);
        }
        //could have been the event "ng-mousemove", but this event calls automatically scope.$watch
        //here we only call scope.$watch when the value form.selected has changed
        function mouseToObject(event) {
            var x = event.offsetX / width() * 2 - 1;
            var y = -(event.offsetY / height()) * 2 + 1;
            // console.log(event.clientX + " " + event.clientY);
            return selected = globe.FindIntersect(x, y);
        }
        function onWindowResize() {
            globe.SetAspectRatio(width(), height());
        }
        //instantiate the globe and set eventListeners
        //scope.$watch('data.all', onDataChanged);
        //we watch the legend. (we also use the data.filter, but they are updated at the same time so it's redundant to observe booth values)
        // becarefull to not watch data.legend with true as it's heavy. Anyway, the legend is only updated when there are effectives changes !
        scope.$watch("legend", update);
        scope.$watch("hovered.get()", function(oldVal, newVal) {
            if (oldVal[0]) {
                globe.UpdatePoints(oldVal, {
                    opacity: 1
                });
            }
            if (newVal[0]) {
                globe.UpdatePoints(newVal, {
                    opacity: 1
                });
            }
        });
        var mouseMove = function(event) {
            var hovered = mouseToObject(event);
            if (hovered) {
                container.style.cursor = "pointer";
                scope.tooltipShow = true;
                scope.pageX = event.offsetX;
                scope.pageY = event.offsetY;
                scope.tooltipData = new legendProvider.Feature(scope.legend, legendProvider.getColumn(hovered, scope.legend.name)).getDistinctValuesArray();
                for (var i in scope.tooltipData) {
                    scope.tooltipData[i].color = scope.legend.getDistinctValues()[scope.tooltipData[i].value].color;
                }
            } else {
                container.style.cursor = "-webkit-grab";
                scope.tooltipShow = false;
            }
            //todo: remove the duplicated set
            scope.hovered.set(hovered);
            scope.hovered.set(hovered);
        };
        container.addEventListener("mousemove", mouseMove, false);
        container.addEventListener("mouseup", function(e) {
            container.style.cursor = "-webkit-grab";
            container.addEventListener("mousemove", mouseMove, false);
        });
        container.addEventListener("mousedown", function(e) {
            container.style.cursor = "-webkit-grabbing";
            container.removeEventListener("mousemove", mouseMove, false);
        });
        container.addEventListener("click", function(event) {
            scope.selected.set(mouseToObject(event));
        }, false);
        window.addEventListener("resize", onWindowResize, false);
    }
    return {
        restrict: "E",
        //directive restricter to element name because we define a wole element (and not just a behavior)
        //scope: {form: '=form'},
        scope: {
            values: "=",
            legend: "=",
            selected: "=?",
            hovered: "=?",
            cameraPosition: "=",
            globalView: "=",
            globeTexture: "=?",
            backgroundTexture: "=?"
        },
        template: "<tooltip-directive show='tooltipShow' x='pageX' y='pageY'> <div class='panel panel-default'> " + " <div class='panel-heading'>  <h3 class='panel-title'>{{legend.alias}} of {{hovered.get()[0].length}} elements</h3> </div>" + "<bar-chart-directive values='tooltipData' values-type='data.legend.type' xaxis=\"'value'\" yaxis=\"'support'\" xaxisunit='legend.unit' />" + "</div></tooltip-directive>",
        link: link
    };
} ]);

//partial view to create a globe with data on it. 
//it abstract the creation of the 3D scene and update it thanks to public methods like CreatePoints and so on.
var Globe = function(Container, Width, Height, cameraPosition, maxZoomReachDlg, globeTexture, backgroundTexture) {
    if (!Detector.webgl) {
        Detector.addGetWebGLMessage();
        return;
    }
    //globe base elements
    var radius = 200;
    var sphereMesh;
    //scene base elements
    var renderer, scene, camera, controls;
    var meshs = {}, sphere, group, facesIndex = [];
    var maxValue;
    //raycasting elements
    var vector = new THREE.Vector3(1, 1, 1);
    //var projector = new THREE.Projector();
    var ray = new THREE.Raycaster();
    var intersects;
    var selected = null;
    //add the scene with a globe 
    function init() {
        //initialization of the sphere representing the globe
        var Shaders = {
            earth: {
                uniforms: {
                    texture: {
                        type: "t",
                        value: null
                    }
                },
                vertexShader: [ "varying vec3 vNormal;", "varying vec2 vUv;", "void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "vNormal = normalize( normalMatrix * normal );", "vUv = uv;", "}" ].join("\n"),
                fragmentShader: [ "uniform sampler2D texture;", "varying vec3 vNormal;", "varying vec2 vUv;", "void main() {", "vec3 diffuse = texture2D( texture, vUv ).xyz;", "float intensity = 1.05 - dot( vNormal, vec3( 0.0, 0.0, 1.0 ) );", "vec3 atmosphere = vec3( 1.0, 1.0, 1.0 ) * pow( intensity, 3.0 );", "gl_FragColor = vec4( diffuse + atmosphere, 1.0 );", "}" ].join("\n")
            },
            atmosphere: {
                uniforms: {},
                vertexShader: [ "varying vec3 vNormal;", "void main() {", "vNormal = normalize( normalMatrix * normal );", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"),
                fragmentShader: [ "varying vec3 vNormal;", "void main() {", "float intensity = pow( 0.8 - dot( vNormal, vec3( 0, 0, 1.0 ) ), 12.0 );", "gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 ) * intensity;", "}" ].join("\n")
            }
        };
        var sphereGeometrie = new THREE.SphereGeometry(radius, 40, 30);
        var sphereShader = Shaders["earth"];
        var uniforms = THREE.UniformsUtils.clone(sphereShader.uniforms);
        uniforms["texture"].value = THREE.ImageUtils.loadTexture(globeTexture);
        var material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: sphereShader.vertexShader,
            fragmentShader: sphereShader.fragmentShader
        });
        //var material = new THREE.MeshLambertMaterial({
        //    map : THREE.ImageUtils.loadTexture("data/assets/world.jpg"),
        //});
        //material.emissive.setHex("0xffffff");
        sphereMesh = new THREE.Mesh(sphereGeometrie, material);
        sphereMesh.rotation.y = Math.PI;
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(30, Width / Height, .1, 2e4);
        var position = geoCoordinateToScene(cameraPosition.latitude, cameraPosition.longitude, cameraPosition.radius * radius);
        camera.position.x = position.x;
        camera.position.y = position.y;
        camera.position.z = position.z;
        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(Width, Height);
        // renderer.domElement.style.position = 'absolute';
        Container.appendChild(renderer.domElement);
        //Enable controls
        //the container can't be the
        // - element[0]
        // - element.get(0)
        // - angular.element(element)[0]
        //but should be element.context.
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.noPan = true;
        //controls.noRoll = true;
        controls.minDistance = 225;
        controls.maxDistance = 5e3;
        controls.minDistanceReachDlg = maxZoomReachDlg;
        controls.dynamicDampingFactor = .9;
        controls.rotateSpeed = .5;
        controls.autoRotate = true;
        controls.autoRotateSpeed = .2;
        controls.autoRotateIdle = 6e3;
        //var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        //directionalLight.position.z = 4000;
        //scene.add(directionalLight);
        //space
        var cubemap = THREE.ImageUtils.loadTexture(backgroundTexture);
        // load textures
        cubemap.wrapS = THREE.RepeatWrapping;
        cubemap.wrapT = THREE.RepeatWrapping;
        cubemap.repeat.set(10, 10);
        var skyBoxMaterial = new THREE.MeshBasicMaterial({
            map: cubemap,
            side: THREE.BackSide
        });
        // create skybox mesh
        var skybox = new THREE.Mesh(new THREE.BoxGeometry(6e3, 6e3, 6e3), skyBoxMaterial);
        scene.add(skybox);
        scene.add(sphereMesh);
    }
    init();
    //funtion to get shapes 
    function ShapeFactory(letter) {
        if (letter) return new THREE.TextGeometry(letter, {
            size: 1.5,
            height: 1
        }); else return new THREE.BoxGeometry(.75, .75, 1);
    }
    function geoCoordinateToScene(latitude, longitude, radius) {
        var phi = (90 - latitude) * Math.PI / 180;
        //convert latitude to polar angle (in radiants)
        var theta = (180 - longitude) * Math.PI / 180;
        //convert longitude to azimutal angle (in radiants)
        var x = radius * Math.sin(phi) * Math.cos(theta);
        var y = radius * Math.cos(phi);
        var z = radius * Math.sin(phi) * Math.sin(theta);
        return {
            x: x,
            y: y,
            z: z
        };
    }
    //we assume that the point is on a sphere which is at the center of the scene
    function sceneToGeoCoordinate(x, y, z, globeRadius) {
        var radius = Math.sqrt(x * x + y * y + z * z);
        var phi = Math.acos(y / radius);
        var theta = Math.atan2(z, x);
        var phiDeg = phi * 180 / Math.PI;
        var thetaDeg = theta * 180 / Math.PI;
        if (thetaDeg > 0) thetaDeg = 180 - thetaDeg; else thetaDeg = -thetaDeg - 180;
        return {
            latitude: 90 - phiDeg,
            longitude: thetaDeg,
            radius: radius / globeRadius
        };
    }
    var createPoint = function(Point, LatitudeDlg, LongitudeDlg) {
        var geometry = new ShapeFactory();
        geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -.5));
        var mesh = new THREE.Mesh(geometry);
        var position = geoCoordinateToScene(LatitudeDlg(Point), LongitudeDlg(Point), radius);
        mesh.position.x = position.x;
        mesh.position.y = position.y;
        mesh.position.z = position.z;
        mesh.lookAt(sphereMesh.position);
        mesh.updateMatrix();
        //add the data of each point to their mesh
        mesh.userData = Point;
        return mesh;
    };
    this.Update = function(Points, LatitudeDlg, LongitudeDlg, valueDlg, Legend) {
        scene.remove(group);
        var mergedNode = new THREE.Geometry();
        for (var i in Points) {
            var point = Points[i];
            var value = valueDlg(point);
            var mesh = createPoint(point, LatitudeDlg, LongitudeDlg);
            if (Legend.type == "RANGE") {
                mesh.scale.z = 1 + 100 * value.valueNormalized;
                var hexColor = value.color.substring(1, 7);
                mesh.material.color.setHex("0x" + hexColor);
            } else {
                mesh.scale.z = 10 + 10 * value.supportNormalized;
                var hexColor = value.color.substring(1, 7);
                mesh.material.color.setHex("0x" + hexColor);
            }
            for (var face in mesh.geometry.faces) {
                mesh.geometry.faces[face].color = mesh.material.color;
                mesh.geometry.faces[face].userData = mesh.userData;
            }
            mesh.updateMatrix();
            mergedNode.merge(mesh.geometry, mesh.matrix, mesh.material);
        }
        mergedNode.colors = [];
        mergedNode.colorsNeedUpdate = true;
        group = new THREE.Mesh(mergedNode, new THREE.MeshBasicMaterial({
            vertexColors: THREE.FaceColors
        }));
        //group.material.emissive.setHex("0xffffff");
        group.userData = Points;
        group.name = "NodesMerged";
        scene.add(group);
    };
    this.UpdatePoints = function(dataArray, style) {
        for (var i in dataArray) {
            var index = group.userData.indexOf(dataArray[i]) * 12;
            if (index != -1) {
                for (var j = index; j < index + 12; j++) {
                    // group.geometry.faces[j].color.setRGB(1, 1, 1);
                    group.geometry.faces[j].materialIndex = 2;
                }
            }
        }
        group.geometry.colorsNeedUpdate = true;
    };
    this.FindIntersect = function(x, y) {
        if (!group) return null;
        vector.set(x, y, 1);
        vector.unproject(camera);
        ray.set(camera.position, vector.sub(camera.position).normalize());
        intersects = ray.intersectObject(group);
        if (intersects.length) {
            var index = Math.floor(intersects[0].faceIndex / 12);
            return group.userData[index];
        }
        return null;
    };
    //to call on WindowResize
    this.SetAspectRatio = function(width, height) {
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
    };
    //finally render the globe
    function render() {
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(render);
        var position = sceneToGeoCoordinate(camera.position.x, camera.position.y, camera.position.z, radius);
        cameraPosition.latitude = position.latitude;
        cameraPosition.longitude = position.longitude;
        cameraPosition.radius = position.radius;
    }
    render();
};

/**
 * @ngdoc directive
 * @name home.views.leafletDirective
 * @description display a 2D map with markers 
 *
 * @requires home.views.entryDirective
 * @requires graphs.views.tooltipDirective
 */
angular.module("home").directive("leafletDirective", [ "$rootScope", function($rootScope) {
    function link(scope, element, attrs) {
        var container = element[0];
        container.height = element[0].height;
        container.width = element[0].width;
        var latitude = attrs.latitude || 48.8567;
        var longitude = attrs.longitude || 2.3508;
        var zoom = attrs.zoom || 6;
        var map = L.map(container, {
            zoomControl: false
        }).setView([ latitude, longitude ], zoom);
        map.on("zoomend", function(e) {
            if (e.target._animateToZoom < 4) {
                $rootScope.$broadcast("maxZoomOut", {
                    position: e.target._initialCenter
                });
            }
        });
        L.tileLayer("http://{s}.tiles.mapbox.com/v3/mzehren.k7al5m2g/{z}/{x}/{y}.png", {
            maxZoom: 18
        }).addTo(map);
        var markers = [];
        function updataData(data, legend) {
            for (var i in markers) {
                map.removeLayer(markers[i]);
            }
            markers = [];
            var ordonned = data.sort(function(a, b) {
                var valueA = legend.distinctValues[a[legend.name]].value;
                var valueB = legend.distinctValues[b[legend.name]].value;
                if (valueA && valueB && valueA > valueB) return -1; else return 1;
            });
            for (var i in ordonned) {
                var row = ordonned[i];
                if (!row.geo_lat || !row.geo_long) continue;
                var size = .1, color = "blue";
                if (legend) {
                    var value = legend.distinctValues[row[legend.name]];
                    if (legend.type == "RANGE") {
                        size = value.valueNormalized;
                        if (size < .5) {
                            size = .5;
                        }
                    } else {
                        size = .5 + value.supportNormalized / 2;
                    }
                    color = value.color;
                }
                var circle = L.circle([ row.geo_lat, row.geo_long ], 100 * size, {
                    stroke: false,
                    opacity: 1,
                    fillColor: color,
                    fillOpacity: .5
                });
                circle.data = row;
                markers.push(circle);
                if (scope.selected) circle.on("click", function(event) {
                    if (scope.selected.contains(event.target.data)) {
                        scope.selected.set();
                    } else {
                        scope.selected.set();
                        scope.selected.set(event.target.data);
                    }
                });
                if (scope.hovered) circle.on("mouseover", function(event) {
                    scope.tooltipShow = true;
                    scope.pageX = event.originalEvent.layerX;
                    scope.pageY = event.originalEvent.layerY;
                    scope.hovered.set(event.target.data);
                }).on("mouseout", function(event) {
                    scope.tooltipShow = false;
                    scope.hovered.set(null);
                });
                circle.addTo(map);
            }
        }
        function updateCircle(dataArray, style) {
            var circle = markers.filter(function(e) {
                for (var i in dataArray) {
                    if (e.data == dataArray[i]) return true;
                }
            });
            for (var i in circle) {
                circle[i].setStyle(style);
            }
        }
        scope.$watch("legend", function(event) {
            updataData(scope.values, scope.legend);
        });
        scope.$watch("hovered.get()", function(newVal, oldVal) {
            if (oldVal && oldVal[0]) {
                updateCircle(oldVal, {
                    fillOpacity: .8
                });
            }
            if (newVal && newVal[0]) {
                updateCircle(newVal, {
                    fillOpacity: 1
                });
            }
        });
        scope.$watch("selected.get()", function(newVal, oldVal) {
            if (oldVal && oldVal[0]) {
                updateCircle(oldVal, {
                    stroke: false
                });
            }
            if (newVal && newVal[0]) {
                updateCircle(newVal, {
                    stroke: true
                });
            }
        });
    }
    return {
        scope: {
            values: "=",
            legend: "=",
            selected: "=",
            hovered: "="
        },
        template: "<tooltip-directive show='tooltipShow' x='pageX' y='pageY'> <entry-directive entry='hovered.get()[0]'/> </tooltip-directive>",
        link: link
    };
} ]);

angular.module("neighbors").controller("NeighborsController", [ "$scope", "$http", "cancellableHttpService", function($scope, $http, cancellableHttpService) {
    $scope.neighbor = {};
    $scope.neighborArray = [];
    $scope.loading = false;
    $scope.kNeighbors = 5;
    var cancellableHttp = new cancellableHttpService();
    $scope.$watch(function() {
        var impactingValues = [];
        $scope.form.where.forEach(function(value) {
            if (value.value) impactingValues.push(value.value);
        });
        impactingValues.push($scope.kNeighbors);
        impactingValues.push($scope.radius);
        return impactingValues;
    }, function(value, oldValue) {
        if (value == oldValue) return;
        value = $scope.form.where;
        var sample = {};
        for (where in value) {
            if (value[where].feature.type == "Date") sample[value[where].feature.name] = value[where].value.timestamp; else sample[value[where].feature.name] = value[where].value;
        }
        var promise = cancellableHttp.get("/poqemon/poqemon/data/preprocess/cluster/k-mean/nearestNeighbors.py", {
            params: {
                sample: sample,
                kNeighbors: $scope.kNeighbors,
                radius: $scope.radius
            }
        });
        $scope.loading = true;
        promise.success(function(data) {
            $scope.loading = false;
            $scope.neighbor = data;
            $scope.neighborArray = [];
            for (feature in data) $scope.neighborArray.push({
                feature: feature,
                value: data[feature]
            });
        });
    }, true);
} ]);

angular.module("apriori").directive("associateDirective", [ "$http", function($http) {
    function link(scope, element, attrs) {
        scope.$watch("clicked", function(value) {
            for (var i in scope.rules) scope.rules[i].isOpen = scope.check(value, scope.rules[i]);
        });
        scope.check = function(object, rule) {
            if (!object) return false; else if (object == rule) return true; else if (rule.Antecedent.filter(function(e) {
                return e.Attribute == object.Attribute && e.Value == object.Value;
            }).length != 0 || rule.Consequent.filter(function(e) {
                return e.Attribute == object.Attribute && e.Value == object.Value;
            }).length != 0) return true; else return false;
        };
    }
    return {
        restrict: "E",
        scope: {
            rules: "=",
            hovered: "=",
            clicked: "="
        },
        templateUrl: function(elem, attrs) {
            return "app/components/apriori/views/associate.html";
        },
        link: link
    };
} ]);

angular.module("apriori").filter("jsonFilter", function() {
    return function(json) {
        var result = "";
        for (var i in json) {
            for (var j in json[i]) {
                result += json[i][j] + "<br/>";
            }
        }
        return result;
    };
});

angular.module("apriori").directive("ruleDirective", [ "$http", function($http) {
    function link(scope, element, attrs) {}
    return {
        restrict: "E",
        scope: {
            rule: "="
        },
        templateUrl: function(elem, attrs) {
            return "app/components/apriori/views/rule.html";
        },
        link: link
    };
} ]);

/**
 * @ngdoc controller
 * @name home.controllers.FormController
 *
 * @description contains the behavior for retreiving, selecting and filtering data.
 * 
 */
angular.module("home").controller("TestController", [ "$scope", "$http", "$timeout", "dataAccessProvider", "legendProvider", "filterProvider", "dataFeaturesEnum", function($scope, $http, $timeout, dataAccessProvider, legendProvider, filterProvider, dataFeaturesEnum) {
    //scope
    $scope.data = [];
    $scope.filtered = [];
    $scope.legendized = {};
    var baseLegend = {};
    //scope.data behavior
    dataAccessProvider.csv("data/data.csv", //"data/POQEMON/dataCompressed.csv",
    function(value) {
        $scope.data = legendProvider.parseData(value, dataFeaturesEnum);
    }, function(error) {
        window.alert("couldn't load data : status \"" + error.statusText + '"');
    });
    $scope.$watch("data", function(value) {
        if (!value.length) return;
        filterProvider.setData(value);
        filterProvider.setConditions([]);
        $scope.filtered = filterProvider.getResult();
        var featuresNames = [ "model", "network_operator_name", "speed_download", "network_type.group_name", "city" ];
        featuresNames.forEach(function(featureIdx, idx) {
            var feature = dataFeaturesEnum[featureIdx];
            var filteredLegend = new legendProvider.Feature(feature, legendProvider.getColumn(value, feature.name));
            baseLegend[feature.name] = filteredLegend;
        });
    });
    $scope.$watch("filtered", function(value) {
        var startTime = new Date();
        var featuresNames = [ "model", "network_operator_name", "speed_download", "network_type.group_name", "city" ];
        featuresNames.forEach(function(featureIdx, idx) {
            var feature = dataFeaturesEnum[featureIdx];
            var filteredLegend = new legendProvider.Feature(feature, legendProvider.getColumn(value, feature.name));
            filteredLegend.distinctValuesArray.forEach(function(filteredValue, idx) {
                filteredValue.color = baseLegend[feature.name].distinctValues[filteredValue.value].color;
            });
            $scope.legendized[feature.name] = filteredLegend;
        });
        console.log("legend : " + (new Date() - startTime));
    });
    var Where = function(feature) {
        this.feature = feature;
        /**
             * @ngdoc property
             * @name home.controllers.FormController.Where:value
             * @description The value used to filter
             */
        this.value = null;
        this.minValue = null;
        this.maxValue = null;
        this.timeout = 1e3;
        var _play = false;
        this.indexValue = null;
    };
    $scope.where = [];
    //scope.form behavior
    $scope.addWhere = function(feature, where) {
        var whereNewRef = new Where();
        if (where) {
            for (var i in where) whereNewRef[i] = where[i];
        }
        if (feature) whereNewRef.feature = feature; else whereNewRef.feature = form.select;
        $scope.where.push(whereNewRef);
    };
    $scope.removeWhere = function(index) {
        $scope.where.splice(index, 1);
    };
    //we watch the "where" conditions to filter the data and create a new legend.
    //because the Feature objects are really big, we have to obsere only some fields
    //and only call the callback when there are effectives changes in the conditions
    $scope.$watch(function() {
        var impactingValues = [];
        $scope.where.forEach(function(value) {
            if (value.minValue || value.maxValue || value.value) impactingValues.push({
                value: value.value,
                minValue: value.minValue,
                maxValue: value.maxValue
            });
        });
        return impactingValues;
    }, function(newVal, oldVal) {
        var startTime = new Date();
        if (newVal == oldVal) return;
        filterProvider.setConditions($scope.where);
        $scope.filtered = filterProvider.getResult();
        console.log("filter : " + (new Date() - startTime));
    }, true);
} ]);

/**
 * @ngdoc directive
 * @name graphs.views.3dPlotDirective
 * @description 3d viz for webGL. uses values in x, y, z, w attributes of the islolated scope.
 *
 * @requires graphs.views.tooltipDirective
 * @requires home.model.clusterProvider
 */
angular.module("graphs").directive("plotDirective", [ "$window", "$filter", "clusterProvider", "colorProvider", "legendProvider", function($window, $filter, clusterProvider, colorProvider, legendProvider) {
    function link(scope, element, attrs) {
        var scene, camera, renderer, controls, width, height, group;
        var container = element[0];
        var heightMultiplicator = 2;
        //raycasting elements
        var vector = new THREE.Vector3(1, 1, 1);
        var ray = new THREE.Raycaster();
        var intersects;
        var width = element.parent().width();
        var height = width;
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(30, width / height, .1, 2e4);
            camera.position.set(0, 147.87683151467763, 383.66273879251384);
            camera.lookAt(new THREE.Vector3(-.3616576394043221, .010137533292509741, .0038349093063501614));
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(width, height);
            renderer.domElement.style.position = "absolute";
            container.appendChild(renderer.domElement);
            //Enable controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            //controls.noPan = true;
            //controls.noRoll = true;
            controls.minDistance = 10;
            controls.maxDistance = 5e3;
            controls.dynamicDampingFactor = .9;
            controls.rotateSpeed = .5;
            controls.autoRotate = false;
            // axes
            axes = new THREE.AxisHelper(10);
            scene.add(axes);
        }
        init();
        function update() {
            scope.labels = legendProvider.computeLabels(scope.matrix);
            scene.remove(group);
            var mergedNode = new THREE.Geometry();
            var i = 1;
            for (var row in scope.labels.rows) {
                var j = 1;
                for (var column in scope.labels.columns) {
                    if (scope.matrix[row][column] !== undefined) {
                        var value = legendProvider.normalize(scope.matrix[row][column], scope.labels.columns[column].minValue, scope.labels.columns[column].maxValue);
                        var geometry = new THREE.BoxGeometry(.75, 1, .75);
                        var mesh = new THREE.Mesh(geometry);
                        mesh.position.x = j;
                        mesh.position.z = i;
                        //mesh.userData = {column: column, row: row, value: value}
                        var height = heightMultiplicator * value;
                        mesh.scale.set(1, height / 2, 1);
                        mesh.position.y = height / 4;
                        var hexColor = colorProvider(value, "RANGE").substring(1, 7);
                        mesh.material.color.setHex("0x" + hexColor);
                        for (var face in mesh.geometry.faces) {
                            mesh.geometry.faces[face].color = mesh.material.color;
                            mesh.geometry.faces[face].userData = mesh.userData;
                        }
                        mesh.updateMatrix();
                        mergedNode.merge(mesh.geometry, mesh.matrix, mesh.material);
                    }
                    j++;
                }
                i++;
            }
            mergedNode.colors = [];
            mergedNode.colorsNeedUpdate = true;
            group = new THREE.Mesh(mergedNode, new THREE.MeshBasicMaterial({
                vertexColors: THREE.FaceColors
            }));
            //group.userData = scope.matrix;
            group.name = "NodesMerged";
            scene.add(group);
        }
        function findIntersect(x, y) {
            if (!group) return null;
            vector.set(x, y, 1);
            vector.unproject(camera);
            ray.set(camera.position, vector.sub(camera.position).normalize());
            intersects = ray.intersectObject(group);
            if (intersects.length) {
                var index = Math.floor(intersects[0].faceIndex / 12);
                //dirty search
                var i = 0;
                for (var row in scope.matrix) {
                    for (var column in scope.matrix[row]) {
                        if (i == index) return {
                            column: column,
                            row: row,
                            value: scope.matrix[row][column]
                        };
                        i++;
                    }
                }
            }
            return null;
        }
        //finally render
        function render() {
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }
        render();
        //watchers !
        scope.$watch("matrix", update);
        function mouseToObject(event) {
            var x = event.offsetX / width * 2 - 1;
            var y = -(event.offsetY / height) * 2 + 1;
            // console.log(event.clientX + " " + event.clientY);
            return selected = findIntersect(x, y);
        }
        scope.tooltipShow = false;
        var mouseMove = function(event) {
            var hovered = mouseToObject(event);
            if (hovered) {
                container.style.cursor = "pointer";
                scope.tooltipShow = true;
                scope.pageX = event.offsetX;
                scope.pageY = event.offsetY;
                scope.tooltipData = hovered;
            } else {
                container.style.cursor = "-webkit-grab";
                scope.tooltipShow = false;
            }
            scope.interaction.node.emphasized.set(hovered);
        };
        container.addEventListener("mousemove", mouseMove, false);
        container.addEventListener("mouseup", function(e) {
            container.style.cursor = "-webkit-grab";
            container.addEventListener("mousemove", mouseMove, false);
        });
        container.addEventListener("mousedown", function(e) {
            container.style.cursor = "-webkit-grabbing";
            container.removeEventListener("mousemove", mouseMove, false);
        });
    }
    return {
        restrict: "E",
        template: "<tooltip-directive show='tooltipShow' x='pageX' y='pageY' update='tooltipData'> <div class='panel panel-default'> " + " <div class='panel-heading'>  <h3 class='panel-title'>{{tooltipData.column}} - {{tooltipData.row}} = {{tooltipData.value}}</h3> </div>" + "</div></tooltip-directive>",
        scope: {
            matrix: "=",
            interaction: "=",
            normalize: "=?"
        },
        link: link
    };
} ]);

/**
 * @ngdoc directive
 * @name graphs.views.barChartDirective
 * @description Display a histogram of an array of values
 *
 * @requires graphs.views.tooltipDirective
 * @requires home.model.clusterProvider
 */
angular.module("graphs").directive("barChartDirective", [ "$window", "$filter", "$timeout", "clusterProvider", function($window, $filter, $timeout, clusterProvider) {
    function link(scope, element, attrs) {
        //@media (min-width: 992px)
        var container = element[0];
        var svg = d3.select(container).append("svg");
        var g = svg.append("g");
        var domXAxis = g.append("g");
        var domYAxis = g.append("g");
        var yLabel = g.append("text");
        var xLabel = g.append("text");
        function update() {
            var filterExpression = scope.filterExpression ? scope.filterExpression : function(d) {
                return $filter("number")(d, 3);
            };
            var maxColumn = scope.maxColumn ? scope.maxColumn : 11;
            function getXField(d) {
                if (scope.valuesType == "DISCRET" || scope.valuesType == "ID" || scope.valuesType == "BOOL") {
                    var values = clusterProvider.getFirstAndLastValue(d, scope.xAxis);
                    if (Object.prototype.toString.call(values) === "[object Array]") return values[0] + " - " + values[1]; else return values;
                } else {
                    var values = clusterProvider.getMinAndMaxBoundary(d, scope.xAxis, filterExpression);
                    if (Object.prototype.toString.call(values) === "[object Array]") return (values[0] + " - " + values[1]).toString(); else return values;
                }
            }
            function getYField(d) {
                return clusterProvider.getSumValue(d, scope.yAxis);
            }
            var startTime = new Date();
            if (!scope.values) return;
            var data;
            if (scope.valuesType == "DISCRET" || scope.valuesType == "ID" || scope.valuesType == "BOOL") data = clusterProvider.groupByOrder(scope.values, maxColumn); else {
                if (scope.brush) data = clusterProvider.groupByValues(scope.values, function(d) {
                    return d[scope.xAxis];
                }, maxColumn, true, scope.brush[0], scope.brush[1]); else data = clusterProvider.groupByValues(scope.values, function(d) {
                    return d[scope.xAxis];
                }, maxColumn);
            }
            var containerSizeWidth = element.parent().width();
            var containerSizeHeight = element.parent().width();
            if ($window.innerWidth < 992) {
                containerSizeHeight /= 2;
            }
            if (containerSizeHeight > 300) {
                containerSizeHeight = 300;
            }
            var margin = {
                top: 20,
                right: 0,
                bottom: 70,
                left: 20
            };
            var width = containerSizeWidth - margin.left - margin.right;
            var height = containerSizeHeight - margin.top - margin.bottom;
            domXAxis.attr("class", "x axis").attr("transform", "translate(0," + height + ")");
            domYAxis.attr("class", "y axis");
            var xAxisHeight = domXAxis[0][0].getBBox().height;
            var yAxisWidth = 70;
            //domYAxis[0][0].getBBox().width;
            var x = d3.scale.ordinal().rangeRoundBands([ 0, width - yAxisWidth ], .05);
            var y = d3.scale.linear().range([ height, 0 ]);
            x.domain(data.map(function(d) {
                //the elements of the array passed to domain are cast to string to retreive the output range.
                //So I have to implement the cast to differentiate each element.
                // return getXField(d);
                d.toString = function() {
                    return getXField(d);
                };
                return d;
            }));
            y.domain([ 0, d3.max(data, function(d) {
                return getYField(d);
            }) ]);
            var xAxis = d3.svg.axis().scale(x).orient("bottom");
            var yAxis = d3.svg.axis().scale(y).orient("left");
            function wrap(text, width) {
                if (width > 60) {
                    text.each(function() {
                        var text = d3.select(this), words = text.text().split(/_+/).join(" ").split(/\s+/).reverse(), word, line = [], lineNumber = 0, lineHeight = 1.1, // ems
                        y = 0;
                        text.attr("y"), dy = parseFloat(text.attr("dy")), tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
                        while (word = words.pop()) {
                            line.push(word);
                            tspan.text(line.join(" "));
                            if (tspan.node().getComputedTextLength() > width) {
                                line.pop();
                                tspan.text(line.join(" "));
                                line = [ word ];
                                tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                            }
                        }
                    });
                }
            }
            var domYAxisTransition = domYAxis;
            if (scope.transition) domYAxisTransition = domYAxis.transition("globalTransition").duration(1e3);
            var domXAxisTransition = domXAxis;
            if (scope.transition) domXAxisTransition = domXAxis.transition("globalTransition").duration(1e3);
            domXAxisTransition.call(xAxis);
            var textX = domXAxis;
            textX.selectAll(".tick text").on("mouseover", mouseOver).on("mouseout", mouseOut).on("dblclick", dblClick).style("text-anchor", "end").attr("dx", "-.8em").attr("transform", function(d) {
                return "rotate(-65)";
            });
            domYAxisTransition.call(yAxis);
            svg.attr("width", containerSizeWidth).attr("height", containerSizeHeight + xAxisHeight);
            g.attr("transform", "translate(" + (margin.left + yAxisWidth) + "," + margin.top + ")");
            yLabel.attr("transform", "rotate(-90)").attr("y", 0 - yAxisWidth - 20).attr("x", 0 - height / 2).attr("dy", "1em").style("text-anchor", "middle").text(function() {
                var text = scope.yAxisLabel ? scope.yAxisLabel : scope.yAxis;
                return scope.yAxisUnit ? text + " (" + scope.yAxisUnit + ")" : text;
            });
            xLabel.attr("y", height + xAxisHeight).attr("x", 0 + width / 2).attr("dy", "1em").style("text-anchor", "middle").text(function() {
                var textX = scope.xAxisLabel ? scope.xAxisLabel : scope.xAxis;
                return scope.xAxisUnit ? textX + " (" + scope.xAxisUnit + ")" : textX;
            });
            //-----DATA-----
            var bars = g.selectAll(".bar").data(data, getXField);
            bars.enter().append("rect").attr("class", "bar");
            bars.exit().remove();
            var barsTransitions = bars;
            if (scope.transition) barsTransitions = bars.transition("globalTransition").duration(1e3);
            barsTransitions.style("fill", function(d) {
                return clusterProvider.getMiddleValue(d, "color") ? clusterProvider.getMiddleValue(d, "color") : "black";
            }).attr("x", function(d) {
                return x(d);
            }).attr("width", x.rangeBand()).attr("y", function(d) {
                return y(clusterProvider.getSumValue(d, scope.yAxis));
            }).attr("height", function(d) {
                tmpHeight = height - y(clusterProvider.getSumValue(d, scope.yAxis));
                if (tmpHeight < 0) {
                    return 0;
                } else {
                    return tmpHeight;
                }
            });
            function mouseOver(d) {
                scope.tooltipShow = true;
                scope.tooltipX = d3.event.layerX;
                scope.tooltipY = d3.event.layerY;
                scope.tooltipData = [ scope.yAxis + ": " + getYField(d), scope.xAxis + ": " + getXField(d) ];
                scope.hovered.set(d);
            }
            function mouseOut(d) {
                scope.tooltipShow = false;
                scope.hovered.set(null);
            }
            function dblClick(d) {
                d3.event.stopPropagation();
                scope.$apply(function() {
                    var value, minValue, maxValue;
                    if (scope.valuesType == "DISCRET" || scope.valuesType == "ID" || scope.valuesType == "BOOL") {
                        var values = clusterProvider.getFirstAndLastValue(d, scope.xAxis);
                        if (Object.prototype.toString.call(values) === "[object Array]") {
                            minValue = values[0];
                            maxValue = values[1];
                        } else {
                            value = values;
                        }
                    } else {
                        var values = clusterProvider.getMinAndMaxBoundary(d, scope.xAxis);
                        if (Object.prototype.toString.call(values) === "[object Array]") {
                            minValue = values[0];
                            maxValue = values[1];
                        } else {
                            value = values;
                        }
                    }
                    scope.addWhere(scope.feature, {
                        minValue: minValue,
                        maxValue: maxValue,
                        value: value
                    });
                });
            }
            bars.on("mouseover", mouseOver).on("mouseout", mouseOut).on("dblclick", dblClick);
            console.log("update : " + (new Date() - startTime));
        }
        //TODO: unbind ?
        angular.element($window).bind("resize", function() {
            scope.$apply();
        });
        //update the size of the barchart when it is resized
        scope.$watch(function() {
            return [ element.parent().width(), element.parent().height() ];
        }, function(value, oldValue) {
            if (value == oldValue) return;
            console.log("resize barchart! : " + value);
            update();
        }, true);
        scope.$watch("values", function(value, oldValue) {
            // if(value == oldValue)
            //     return;
            console.log("values barchart!" + [ element.parent().width(), element.parent().height() ]);
            $timeout(update);
            //TODO: ressource intensive. I update twice, to check the size of the labels and set the size accordingly
            update();
        }, true);
        scope.$on("refreshChartBarStatus", function() {
            console.log("refreshChartBarStatus barchart!");
            update();
        });
        scope.$watch("selected.get()", function(value) {
            svg.selectAll(".bar").transition("fill").duration(200).style("fill", function(d) {
                return scope.selected.contains(d) ? "red" : clusterProvider.getMiddleValue(d, "color");
            });
        }, true);
        scope.$watch("hovered.get()", function(value) {
            svg.selectAll(".bar").transition("opacity").duration(200).style("opacity", function(d) {
                return scope.hovered.contains(d) ? 1 : .8;
            });
        }, true);
    }
    return {
        restrict: "E",
        scope: {
            values: "=",
            //should be an array of {xAxis: ..., yAxis: ..., color: hex}
            brush: "=?",
            //should be an array [minX, maxX]
            xAxis: "=xaxis",
            xAxisLabel: "=?",
            yAxis: "=yaxis",
            yAxisLabel: "=?",
            xAxisUnit: "=xaxisunit",
            yAxisUnit: "=yaxisunit",
            selected: "=",
            hovered: "=",
            valuesType: "=",
            transition: "=?",
            addWhere: "=?",
            feature: "=?",
            fillDlg: "=?",
            filterExpression: "=?",
            maxColumn: "=?"
        },
        link: link,
        template: "<tooltip-directive show='tooltipShow' x='tooltipX' y='tooltipY'> <div class='panel panel-default'>{{tooltipData[0]}} <br/> {{tooltipData[1]}} </div> </tooltip-directive>"
    };
} ]);

angular.module("graphs").directive("boxPlotDirective", [ "$window", function($window) {
    function link(scope, element, attrs) {
        var container = element[0];
        var svg = d3.select(container).append("svg");
    }
    return {
        template: "<p>{{data.legend}}</p>"
    };
} ]);

angular.module("graphs").directive("circlePackingDirective", [ "$window", "clusterProvider", function($window, clusterProvider) {
    function link(scope, element, attrs) {
        var container = element[0];
        var svg = d3.select(container).append("svg");
        var g = svg.append("g");
        var pack = d3.layout.pack().children(function(d) {
            return d.length ? d : null;
        });
        //.radius(function (d) { return clusterProvider.getSumValue(d, "support") })
        //.value(function (d) { return clusterProvider.getSumValue(d, "support") });
        //var tooltip = d3.select("body").append("div")
        //    .attr("class", "barTooltip")
        //    .style("opacity", 0);
        function update() {
            if (!scope.values) return;
            var data = clusterProvider.groupByOrder(scope.values, 19);
            //-----DOM-----
            var containerSize = element.parent().width();
            var margin = {
                top: 20,
                right: 20,
                bottom: 70,
                left: 50
            }, width = containerSize - margin.left - margin.right, height = containerSize - margin.top - margin.bottom;
            svg.attr("width", containerSize).attr("height", containerSize);
            g.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
            pack.size([ width - 4, width - 4 ]);
            //-----DATA-----
            var nodes = g.selectAll(".node").data(pack.nodes(data));
            nodes.enter().append("g").attr("class", function(d) {
                return d.length ? "node" : "leaf node";
            });
            nodes.attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
            }).attr("fill", function(d) {
                return clusterProvider.getMiddleValue(d, "color");
            }).attr("stroke", function(d) {
                return clusterProvider.getMiddleValue(d, "color");
            });
            nodes.append("title").text(function(d) {
                return clusterProvider.getFirstAndLastValue(d, "value");
            });
            nodes.append("circle").attr("r", function(d) {
                return d.r;
            });
            nodes.exit().remove();
        }
        angular.element($window).bind("resize", function() {
            update();
        });
        scope.$watch("values", function(value) {
            update();
        }, true);
        scope.$watch("selected.get()", function(value) {
            svg.selectAll(".bar").transition("fill").duration(200).style("fill", function(d) {
                return scope.selected.contains(d) ? "red" : clusterProvider.getMiddleValue(d, "color");
            });
        }, true);
        scope.$watch("hovered.get()", function(value) {
            svg.selectAll(".bar").transition("opacity").duration(200).style("opacity", function(d) {
                return scope.hovered.contains(d) ? 1 : .8;
            });
        }, true);
    }
    return {
        restrict: "E",
        scope: {
            values: "=",
            //should be an array of {value: string, support: int, color: hex}
            xAxis: "=xaxis",
            yAxis: "=yaxis",
            selected: "=",
            hovered: "="
        },
        link: link
    };
} ]);

angular.module("graphs").directive("dendrogramDirective", [ "$window", "$timeout", "Node", "legendProvider", function($window, $timeout, Node, legendProvider) {
    function link(scope, element, attrs) {
        //DOM appending
        var container = element[0];
        // Calculate total nodes, max label length
        var totalNodes = 0;
        var maxLabelLength = 0;
        // variables for drag/drop
        var selectedNode = null;
        var draggingNode = null;
        var overSVG = false;
        // panning variables
        var panSpeed = 200;
        var panBoundary = 20;
        // Within 20px from edges will pan when dragging.
        // Misc. variables
        var i = 0;
        var duration = 750;
        var root = {};
        // size of the diagram
        var viewerWidth = element.parent().width();
        var viewerHeight = element.parent().height();
        var tree = d3.layout.tree();
        // define a d3 diagonal projection for use by the node paths later on.
        var diagonal = d3.svg.diagonal().projection(function(d) {
            return [ d.y, d.x ];
        });
        function filterTree(parent, filterFn) {
            if (!parent) return;
            parent = shallowCopy(parent);
            if (parent.children) {
                parent.children = parent.children.filter(filterFn);
                for (var i in parent.children) filterTree(parent.children[i], filterFn);
            }
            if (parent._children) {
                parent._children = parent._children.filter(filterFn);
                for (var i in parent._children) filterTree(parent._children[i], filterFn);
            }
            return parent;
        }
        function deepCopy(oldObj) {
            return jQuery.extend(true, {}, oldObj);
        }
        function shallowCopy(oldObj) {
            var newObj = {};
            for (var i in oldObj) {
                if (oldObj.hasOwnProperty(i)) {
                    newObj[i] = oldObj[i];
                }
            }
            return newObj;
        }
        // sort the tree according to the node names
        function sortTree() {
            // legendProvider.sort()
            tree.sort(function(a, b) {
                return b.name.toLowerCase() < a.name.toLowerCase() ? 1 : -1;
            });
        }
        // TODO: Pan function, can be better implemented : when a node is endrag outside of the windiw, it breaks the panning
        function pan(domNode, direction) {}
        // Define the zoom function for the zoomable tree
        function zoom() {
            svgGroup.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
        }
        // define the zoomListener which calls the zoom function on the "zoom" event constrained within the scaleExtents
        var zoomListener = d3.behavior.zoom().scaleExtent([ .1, 3 ]).on("zoom", zoom);
        function initiateDrag(d, domNode) {
            draggingNode = d;
            d3.select(domNode).select(".ghostCircle").attr("pointer-events", "none");
            d3.selectAll(".ghostCircle").attr("class", function(d) {
                var newNode = shallowCopy(draggingNode);
                newNode.parent = d;
                if (!scope.canMoveNode || scope.canMoveNode(draggingNode, newNode)) {
                    return "ghostCircle show";
                }
                return "ghostCircle";
            });
            d3.select(domNode).attr("class", "node activeDrag");
            svgGroup.selectAll("g.node").sort(function(a, b) {
                // select the parent and sort the path's
                if (a.id != draggingNode.id) return 1; else return -1;
            });
            // if nodes has children, remove the links and nodes
            if (nodes.length > 1) {
                // remove link paths
                links = tree.links(nodes);
                nodePaths = svgGroup.selectAll("path.link").data(links, function(d) {
                    return d.target.id;
                }).remove();
                // remove child nodes
                nodesExit = svgGroup.selectAll("g.node").data(nodes, function(d) {
                    return d.id;
                }).filter(function(d, i) {
                    if (d.id == draggingNode.id) {
                        return false;
                    }
                    return true;
                }).remove();
            }
            // remove parent link
            parentLink = tree.links(tree.nodes(draggingNode.parent));
            svgGroup.selectAll("path.link").filter(function(d, i) {
                if (d.target.id == draggingNode.id) {
                    return true;
                }
                return false;
            }).remove();
            dragStarted = null;
        }
        // define the baseSvg, attaching a class for styling and the zoomListener
        var baseSvg = d3.select(container).append("svg").attr("width", viewerWidth).attr("height", viewerHeight).attr("class", "overlay").on("mouseover", function(svg) {
            overSVG = true;
        }).on("mouseout", function(svg) {
            overSVG = false;
        }).call(zoomListener);
        function getIntersection(node, boundingBox) {
            if (node.x < boundingBox.x || node.x > boundingBox.x + boundingBox.width || node.y < boundingBox.y || node.y > boundingBox.y + boundingBox.height) return false;
            return true;
        }
        // show removing alert
        function displayRemoveAlert(force) {
            //if dragend outside of the svg
            if (!force && !overSVG && scope.canRemoveNode && scope.canRemoveNode(draggingNode)) {
                rectRemoveNode.style("display", "block");
            } else {
                rectRemoveNode.style("display", "none");
            }
        }
        // Define the drag listeners for drag/drop behaviour of nodes.
        dragListener = d3.behavior.drag().on("dragstart", function(d) {
            if (d == root) {
                return;
            }
            dragStarted = true;
            nodes = tree.nodes(d);
            d3.event.sourceEvent.stopPropagation();
        }).on("drag", function(d) {
            scope.$apply(function() {
                scope.clicked = null;
            });
            if (d == root) {
                return;
            }
            if (dragStarted) {
                domNode = this;
                initiateDrag(d, domNode);
            }
            displayRemoveAlert();
            // get coords of mouseEvent relative to svg container to allow for panning
            relCoords = d3.mouse($("svg").get(0));
            if (relCoords[0] < panBoundary) {
                panTimer = true;
                pan(this, "left");
            } else if (relCoords[0] > $("svg").width() - panBoundary) {
                panTimer = true;
                pan(this, "right");
            } else if (relCoords[1] < panBoundary) {
                panTimer = true;
                pan(this, "up");
            } else if (relCoords[1] > $("svg").height() - panBoundary) {
                panTimer = true;
                pan(this, "down");
            } else {
                try {
                    clearTimeout(panTimer);
                } catch (e) {}
            }
            d.x0 += d3.event.dy;
            d.y0 += d3.event.dx;
            var node = d3.select(this);
            node.attr("transform", "translate(" + d.y0 + "," + d.x0 + ")");
            updateTempConnector();
        }).on("dragend", function(d) {
            if (d == root) {
                return;
            }
            domNode = this;
            displayRemoveAlert(true);
            if (!overSVG) {
                //if dragend outside of the svg
                if (scope.canRemoveNode && scope.canRemoveNode(draggingNode)) {
                    var parent = draggingNode.parent;
                    var myNodeChildren = nodeChildren(draggingNode);
                    parent.children = nodeChildren(parent).concat(myNodeChildren).filter(function(d) {
                        return d != draggingNode;
                    });
                    parent._children = null;
                    for (var child in myNodeChildren) {
                        myNodeChildren[child].parent = parent;
                    }
                    draggingNode = parent;
                }
            } else if (selectedNode) {
                //if dragend on a node
                //TODO: use the nodeModel implementation
                var newNode = shallowCopy(draggingNode);
                newNode.parent = selectedNode;
                if (!scope.canMoveNode || scope.canMoveNode(draggingNode, newNode)) {
                    // now remove the element from the parent, and insert it into the new elements children
                    draggingNode.parent.removeChild(draggingNode);
                    selectedNode.addChild(draggingNode);
                    draggingNode.parent = selectedNode;
                    // var index = draggingNode.parent.children.indexOf(draggingNode);
                    // if (index > -1) {
                    //     draggingNode.parent.children.splice(index, 1);
                    // }
                    // if (typeof selectedNode.children !== 'undefined' || typeof selectedNode._children !== 'undefined') {
                    //     if (typeof selectedNode.children !== 'undefined') {
                    //         selectedNode.children.push(draggingNode);
                    //     } else {
                    //         if(!selectedNode._children)
                    //             selectedNode._children = [];
                    //         selectedNode._children.push(draggingNode);
                    //     }
                    // } else {
                    //     selectedNode.children = [];
                    //     selectedNode.children.push(draggingNode);
                    // }
                    // Make sure that the node being added to is expanded so user can see added node is correctly moved
                    selectedNode.toggleChildren(true);
                    sortTree();
                }
            }
            endDrag();
        });
        function endDrag() {
            selectedNode = null;
            d3.selectAll(".ghostCircle").attr("class", "ghostCircle");
            d3.select(domNode).attr("class", "node");
            // now restore the mouseover event or we won't be able to drag a 2nd time
            d3.select(domNode).select(".ghostCircle").attr("pointer-events", "");
            updateTempConnector();
            if (draggingNode !== null) {
                update(root);
                centerNode(draggingNode);
                draggingNode = null;
            }
            scope.$apply();
        }
        var overCircle = function(d) {
            selectedNode = d;
            updateTempConnector();
        };
        var outCircle = function(d) {
            selectedNode = null;
            updateTempConnector();
        };
        // Function to update the temporary connector indicating dragging affiliation
        var updateTempConnector = function() {
            var data = [];
            if (draggingNode !== null && selectedNode !== null) {
                // have to flip the source coordinates since we did this for the existing connectors on the original tree
                data = [ {
                    source: {
                        x: selectedNode.y0,
                        y: selectedNode.x0
                    },
                    target: {
                        x: draggingNode.y0,
                        y: draggingNode.x0
                    }
                } ];
            }
            var link = svgGroup.selectAll(".templink").data(data);
            link.enter().append("path").attr("class", "templink").attr("d", d3.svg.diagonal()).attr("pointer-events", "none");
            link.attr("d", d3.svg.diagonal());
            link.exit().remove();
        };
        // Function to center node when clicked/dropped so node doesn't get lost when collapsing/moving with large amount of children.
        function centerNode(source) {
            scale = zoomListener.scale();
            x = -source.y0;
            y = -source.x0;
            x = x * scale + viewerWidth / 2;
            y = y * scale + viewerHeight / 2;
            d3.select("g").transition().duration(duration).attr("transform", "translate(" + x + "," + y + ")scale(" + scale + ")");
            zoomListener.scale(scale);
            zoomListener.translate([ x, y ]);
        }
        scope.centerNode = centerNode;
        // Toggle children function
        function toggleChildren(d) {
            d.toggleChildren();
            return d;
        }
        // Call visit function to establish maxLabelLength
        var updateTree = function(treeData) {
            // maxLabelLength = 0;
            Node.visit(treeData, function(d) {
                totalNodes++;
                if (d.name) maxLabelLength = Math.max(d.name.length, maxLabelLength);
            }, function(d) {
                return d.children && d.children.length > 0 ? d.children : null;
            });
            // Sort the tree initially incase the JSON isn't in a sorted order.
            sortTree();
        };
        // var isLeaf = function(d){
        //     return !d.children || !d._children ;
        // }
        var textDlg = function(d) {
            return d.name;
        };
        var tooltipWidth = 200;
        var fillDlg = function(d) {
            return d._children ? "lightsteelblue" : "#fff";
        };
        function update(source) {
            // Compute the new height, function counts total children of root node and sets tree height accordingly.
            // This prevents the layout looking squashed when new nodes are made visible or looking sparse when nodes are removed
            // This makes the layout more consistent.
            var levelWidth = [ 1 ];
            var childCount = function(level, n) {
                if (n.children && n.children.length > 0) {
                    if (levelWidth.length <= level + 1) levelWidth.push(0);
                    levelWidth[level + 1] += n.children.length;
                    n.children.forEach(function(d) {
                        childCount(level + 1, d);
                    });
                }
            };
            textDlg = scope.textDlg ? scope.textDlg : textDlg;
            fillDlg = scope.fillDlg ? scope.fillDlg : fillDlg;
            var tooltipWidth = scope.tooltipWidth ? scope.tooltipWidth : tooltipWidth;
            childCount(0, root);
            var newHeight = d3.max(levelWidth) * 25;
            // 25 pixels per line  
            tree = tree.size([ newHeight, viewerWidth ]);
            // Compute the new tree layout.
            var nodes = tree.nodes(root);
            // nodes = nodes.filter(function(d){ 
            //     return !d.hidden? true: false; 
            // });
            var links = tree.links(nodes);
            // links = links.filter(function(d){
            //     return d.source.hidden || d.target.hidden ? false : true;
            // });
            // Set widths between levels based on maxLabelLength.
            nodes.forEach(function(d) {
                d.y = d.depth * (maxLabelLength * 10);
            });
            // Update the nodes…
            node = svgGroup.selectAll("g.node").data(nodes, function(d) {
                return d.id || (d.id = ++i);
            });
            scope.$watch("clicked", function(value) {
                if (value) scope.tooltipShow = true; else scope.tooltipShow = false;
                node.select("circle").style("stroke", function(d) {
                    return d === scope.clicked ? "red" : "steelblue";
                });
            });
            var click = function(d, x, y) {
                scope.$apply(function() {
                    if (scope.clicked !== undefined) {
                        if (x > viewerWidth - (tooltipWidth + 50)) scope.tooltipX = x - (tooltipWidth + 50); else scope.tooltipX = x + 50;
                        scope.tooltipY = y - 50;
                        if (scope.clicked == d) {
                            scope.clicked = null;
                        } else {
                            scope.clicked = d;
                        }
                    }
                });
            };
            // Toggle children on dlbclick.
            var dblclick = function(d) {
                if (scope.toggle) {
                    d = toggleChildren(d);
                    update(d);
                    centerNode(d);
                }
            };
            // Enter any new nodes at the parent's previous position.
            var nodeEnter = node.enter().append("g").call(dragListener).attr("class", "node").attr("transform", function(d) {
                return "translate(" + (source.y0 || source.y) + "," + (source.x0 || source.x) + ")";
            }).on("click", function(d) {
                if (d3.event.defaultPrevented) return;
                // click suppressed
                var x = d3.event.layerX;
                var y = d3.event.layerY;
                clickPromise = $timeout(function() {
                    if (clickPromise.$$state.value != "canceled") click(d, x, y);
                }, 300, false);
            }).on("dblclick", function(d) {
                if (d3.event.defaultPrevented) return;
                // click suppressed
                d3.event.stopPropagation();
                $timeout.cancel(clickPromise);
                dblclick(d);
            });
            var clickPromise;
            nodeEnter.append("circle").attr("class", "nodeCircle").attr("r", 0).style("fill", fillDlg).style("stroke", function(d) {
                return d === scope.clicked ? "red" : "steelblue";
            });
            nodeEnter.append("text").attr("dy", ".35em").attr("class", "nodeText").style("fill-opacity", 0);
            // phantom node to give us mouseover in a radius around it
            nodeEnter.append("circle").attr("class", "ghostCircle").attr("r", 30).attr("opacity", .2).style("fill", "red").attr("pointer-events", "mouseover").on("mouseover", function(node) {
                overCircle(node);
            }).on("mouseout", function(node) {
                outCircle(node);
            });
            // Update the text to reflect whether node has children or not.
            node.select("text").attr("x", function(d) {
                return d.isLeaf() ? 10 : -10;
            }).attr("text-anchor", function(d) {
                return d.isLeaf() ? "start" : "end";
            }).text(textDlg);
            // Change the circle fill depending on whether it has children and is collapsed
            node.select("circle.nodeCircle").attr("r", 4.5).style("fill", fillDlg);
            // Transition nodes to their new position.
            var nodeUpdate = node.transition().duration(duration).attr("transform", function(d) {
                return "translate(" + d.y + "," + d.x + ")";
            });
            // Fade the text in
            nodeUpdate.select("text").style("fill-opacity", 1);
            // Transition exiting nodes to the parent's new position.
            var nodeExit = node.exit().transition().duration(duration).attr("transform", function(d) {
                return "translate(" + source.y + "," + source.x + ")";
            }).remove();
            nodeExit.select("circle").attr("r", 0);
            nodeExit.select("text").style("fill-opacity", 0);
            // Update the links…
            var link = svgGroup.selectAll("path.link").data(links, function(d) {
                return d.target.id;
            });
            // Enter any new links at the parent's previous position.
            link.enter().insert("path", "g").attr("class", "link").attr("d", function(d) {
                var o = {
                    x: source.x0 || source.x,
                    y: source.y0 || source.y
                };
                return diagonal({
                    source: o,
                    target: o
                });
            });
            // Transition links to their new position.
            link.transition().duration(duration).attr("d", diagonal);
            // Transition exiting nodes to the parent's new position.
            link.exit().transition().duration(duration).attr("d", function(d) {
                var o = {
                    x: source.x,
                    y: source.y
                };
                return diagonal({
                    source: o,
                    target: o
                });
            }).remove();
            // Stash the old positions for transition.
            nodes.forEach(function(d) {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }
        // Append a group which holds all nodes and which the zoom Listener can act upon.
        var svgGroup = baseSvg.append("g");
        var rectRemoveNode = baseSvg.append("g").style("display", "none");
        rectRemoveNode.append("rect").attr("width", viewerWidth).attr("height", viewerHeight).style("fill", "blue").style("stroke", "red").style("fill-opacity", "0.2").style("stroke-opacity", "0.3").style("stroke-width", "15").style("z-index", "0");
        rectRemoveNode.append("text").text("REMOVING NODE").style("text-anchor", "middle").style("fill-opacity", "1").attr("x", viewerWidth / 2).attr("y", viewerHeight / 2).style("font-size", "xx-large");
        var breadthFirst = function(root, CB) {
            if (root) {
                if (root.children) {
                    for (var child in root.children) breadthFirst(root.children[child], CB);
                }
                return CB(root);
            }
        };
        //TODO: unbind ?
        angular.element($window).bind("resize", function() {
            scope.$apply();
        });
        //update the size of the barchart when it is resized
        scope.$watch(function() {
            return [ element.parent().width(), element.parent().height() ];
        }, function(value, oldValue) {
            if (value == oldValue) return;
            viewerWidth = element.parent().width();
            viewerHeight = element.parent().height();
            tree.size([ viewerHeight, viewerWidth ]);
            baseSvg.attr("width", viewerWidth).attr("height", viewerHeight);
        }, true);
        // scope.$watch(function(){
        //     var names = [];
        //     root = scope.data ? scope.data : {};
        //     breadthFirst(root, function(d){
        //         names.push({name : textDlg(d) ? textDlg(d) : "", hidden: d.hidden, mappingValue:d.mappingValue})
        //     });
        //     return names;
        // }, function (value, oldValue) {
        //     setData(value);
        // }, true);
        scope.$watch(function() {
            var names = [];
            Node.visit(scope.data, function(node) {
                if (!node.leaf) names.push(node.name + node.getChildren().length);
            }, function(node) {
                return node.getAllChildren();
            });
            return names;
        }, function(value, oldValue) {
            setData(scope.data);
        }, true);
        //some preprocessing and call the update.
        var setData = function(value) {
            // Define the root
            root = value ? value : new Node("Empty");
            // root = filterTree(root, function(d){return !d.hidden});
            root.x0 = viewerHeight / 2;
            root.y0 = 0;
            // Node.visit(root, function(node){
            //     if(!node._children)
            //         node._children = [];
            //     if(!node.children)
            //         node.children = [];
            //     node._children = node._children.concat(node.children.filter(function(d){return d.hidden}));
            //     node.children =  node.children.filter(function(d){return !d.hidden});
            // }, 
            // function(node){
            //     return node.getAllChildren();
            // })
            updateTree(root);
            update(root);
        };
    }
    return {
        restrict: "E",
        scope: {
            data: "=",
            //root node of a tree. The node class is {parent: node, children: [node], _children: [node]}
            toggle: "=?",
            //bool if toggle on dblClick
            textDlg: "=?",
            //function returning the text over the node. default is calling to string.
            clicked: "=?",
            //contains the node Clicked
            fillDlg: "=?",
            //return the color of the node
            canRemoveNode: "=?",
            //dlg called when a node is removed: bool dlg(Node)
            canAddNode: "=?",
            //same: bool dlg(Node)
            canMoveNode: "=?",
            //almost the same: bool dlg(oldNode, newNode)
            tooltipWidth: "=?"
        },
        transclude: true,
        link: link,
        template: function(elem, attrs) {
            return "<tooltip-directive show='tooltipShow' x='tooltipX' y='tooltipY' style='width: {{tooltipWidth}}px'> <ng-transclude></ng-transclude> </tooltip-directive>";
        }
    };
} ]);

/**
 * @ngdoc service
 * @name graphs.dendrogram.Node
 * @description a Node displayed in the graph. Contains some fields like "hidden" "name", and so on
 *
 * TODO: add another class to extend Node in HierarchicalNode
 */
angular.module("graphs").factory("Node", [ "$rootScope", "legendProvider", "cancellableHttpService", "addslashes", function nodeFactory($rootScope, legendProvider, cancellableHttpService, addslashes) {
    var id = 0;
    var Node = function(name, children, feature, leaf, mapping, hidden) {
        if (!name) {
            console.error("name not set!");
        }
        var that = this;
        this.id = ++id;
        this.name = name;
        this.children = children;
        this.feature = feature;
        this.leaf = leaf;
        if (leaf) this.hidden = true;
        this.isLeaf = function() {
            return this.leaf;
        };
        var maxDisplayedChildren = 10;
        this.toggleChildren = function(force) {
            //open the children
            if (force === undefined && this.get_Children().length != 0 || force !== undefined && force) {
                var allChildren = this.getAllChildren();
                if (allChildren.length > maxDisplayedChildren) {
                    this.children = allChildren.slice(0, 100);
                    this._children = allChildren.slice(100);
                } else {
                    this.children = allChildren;
                    this._children = null;
                }
                this._children = null;
            } else if (force === undefined && this.getChildren().length != 0 || force !== undefined && !force) {
                this._children = this.getAllChildren();
                this.children = null;
            }
        };
        // Helper functions for collapsing and expanding nodes.
        this.collapse = function() {
            that.toggleChildren(false);
            that.getAllChildren().forEach(function(d) {
                d.collapse();
            });
        };
        this.expand = function() {
            console.log("expand !");
            that.toggleChildren(true);
            that.getAllChildren().forEach(function(d) {
                d.expand();
            });
        };
        this.isCollapsed = function() {
            var flag = true;
            if (this.getAllChildren().length == 0) return false;
            Node.visit(that, function(node) {
                if (node.getChildren().length) flag = false;
            }, function(node) {
                return node.getChildren();
            });
            return flag;
        };
        this.getChildren = function() {
            if (!this.children) this.children = [];
            return this.children;
        };
        this.get_Children = function() {
            if (!this._children) this._children = [];
            return this._children;
        };
        this.getAllChildren = function() {
            return this.getChildren().concat(this.get_Children());
        };
        this.getAllLeaves = function() {
            var leaves = [];
            Node.visit(this, function(node) {
                if (node.isLeaf()) leaves.push(node);
            }, function(node) {
                return node.getAllChildren();
            });
        };
        this.mappingValue = mapping;
        this.getMappingValue = function() {
            return that.mappingValue;
        };
        this.setMappingValue = function(value) {
            that.mappingValue = value;
        };
        this.mappingParent;
        this.getMappingParent = function() {
            return that.mappingParent;
        };
        this.setMappingParent = function(value) {
            that.mappingParent = value;
            if (that.parent.name == that.feature.name) that.addParent(new Node(value.label, [], that.feature)); else that.changeParent(new Node(value.label, [], that.feature));
        };
        this.remove = function() {
            that.getAllChildren().forEach(function(d) {
                d.parent = that.parent;
            });
            that.parent.removeChild(that);
            that.parent.children = that.parent.getChildren().concat(that.children);
            that.parent._children = that.parent.get_Children().concat(that._children);
        };
        this.getExistingParent = function(parent) {
            var existingParent;
            var doneFlag = false;
            Node.visit(that, function(node) {
                var localChildren = node.getAllChildren();
                for (var parentIdx in localChildren) {
                    if (Node.equal(parent, localChildren[parentIdx])) {
                        existingParent = localChildren[parentIdx];
                        doneFlag = true;
                    }
                }
            }, function(node) {
                if (!doneFlag) return [ node.parent ];
            });
            return existingParent;
        };
        this.getSiblings = function() {
            return that.parent.getAllChildren;
        };
        this.addParent = function(parent) {
            if (!parent) return;
            var existingParent = that.getExistingParent(parent);
            var oldParent = that.parent;
            if (existingParent) {
                existingParent.addChild(that);
                that.parent = existingParent;
            } else {
                that.parent.addChild(parent);
                parent.addChild(that);
                that.parent = parent;
            }
            oldParent.removeChild(that);
        };
        this.changeParent = function(parent) {
            if (!parent) return;
            var existingParent = that.getExistingParent(parent);
            var oldParent = that.parent;
            if (existingParent) {
                existingParent.addChild(that);
                that.parent = existingParent;
            } else {
                that.parent.parent.addChild(parent);
                parent.addChild(that);
                that.parent = parent;
            }
            oldParent.removeChild(that);
        };
        this.removeChild = function(node) {
            var indexOfChild = that.getChildren().indexOf(node);
            var indexOf_Child = that.get_Children().indexOf(node);
            if (indexOfChild != -1) {
                that.children.splice(indexOfChild, 1);
            } else if (indexOf_Child != -1) {
                that._children.splice(indexOf_Child, 1);
            }
            if (that.getAllChildren().length == 0) {
                that.remove();
            }
        };
        this.addChild = function(node) {
            //TODO indexof check the ID of the object, it may not be enough?
            if (that.getAllChildren().indexOf(node) != -1) return false;
            if (that.isCollapsed()) {
                that.get_Children().push(node);
            } else {
                that.getChildren().push(node);
            }
            return true;
        };
        //get or ask for the corresponding DBPedia uri
        //return undefined when the request is pending at the first time, the it returns the good answer
        //a scope.apply is launched anyway when the request is answered
        //a callback can be specified too
        //todo: see if spotlight.dbpedia is better : http://stackoverflow.com/questions/10572606/query-dbpedia-to-find-possible-contexts-to-disambiguate-a-word
        var _mappingValues;
        this.mappingValuesRequest = new cancellableHttpService();
        this.mappingValueSearch = this.name;
        this.getMappingValues = function(callBack) {
            //https://github.com/dbpedia/lookup
            var req = {
                url: "http://lookup.dbpedia.org/api/search.asmx/PrefixSearch",
                params: {
                    MaxHits: 200,
                    QueryString: that.mappingValueSearch
                },
                headers: {
                    Accept: "application/json"
                }
            };
            //We don't need to check if the request was already done, the cancellableHttpService has a cache per instance
            this.mappingValuesRequest.request(req, function(json) {
                _mappingValues = json.results;
                if (!that.mappingValue) that.setMappingValue(_mappingValues[0]); else {
                    //dirty code because this.getMappingValue() returns a copy of the object from tghe thread which is not equal to the corresponding value
                    for (mappingValueIdx in _mappingValues) {
                        if (angular.equals(that.getMappingValue(), _mappingValues[mappingValueIdx])) {
                            that.setMappingValue(_mappingValues[mappingValueIdx]);
                            break;
                        }
                    }
                }
                if (callBack) {
                    callBack(_mappingValues);
                }
            }, function(error) {
                _mappingValues = [];
                if (callBack) {
                    callBack(_mappingValues);
                }
            }, true);
            return _mappingValues;
        };
        this.getMappingParents = function(callBack) {
            var mappingValue = that.getMappingValue();
            if (mappingValue) {
                return mappingValue.categories;
            } else {
                return [];
            }
        };
    };
    //statics functions
    Node.visit = function(parent, visitFn, childrenFn) {
        if (!parent) return;
        visitFn(parent);
        var children = childrenFn(parent);
        if (children) {
            var count = children.length;
            for (var i = 0; i < count; i++) {
                Node.visit(children[i], visitFn, childrenFn);
            }
        }
    };
    Node.equal = function(A, B) {
        return A.name == B.name && A.feature == B.feature;
    };
    //convert to rhoUncertainty format
    Node.serialize = function(node, feature) {
        feature = feature ? feature : node.feature;
        if (node.name != "ALL") return "(u'" + addslashes(feature.name) + "', u'" + addslashes(node.name) + "')"; else return "ALL";
    };
    //convert back from RhoUncertainty format
    Node.deserialize = function(str) {
        if (str == "ALL") return new Node("ALL", null); else {
            var regexExp = /\(u'(.*?)', u'(.*?)'\)/g;
            var match = regexExp.exec(str);
            if (match) {
                if (dataFeatureEnum(match[1])) {
                    var legend = legendProvider.getLegend(value, dataFeatureEnum(match[1]));
                    return new Node(match[2], null, legend);
                } else {
                    return new Node(match[2], null, match[1]);
                }
            }
        }
    };
    Node.getClone = function(node) {
        return JSON.stringify(node, function(key, value) {
            if (key == "parent") {
                return undefined;
            } else return value;
        });
    };
    Node.fromClone = function(node, refFeature) {
        if (typeof node == "string") node = JSON.parse(node);
        refFeature = refFeature ? refFeature : node.feature;
        var result = new Node(node.name, node.children, refFeature, node.leaf, node.mappingValue, node.hidden);
        result._children = node._children;
        for (childIdx in result.getChildren()) result.children[childIdx] = Node.fromClone(result.children[childIdx], refFeature);
        for (childIdx in result.get_Children()) result._children[childIdx] = Node.fromClone(result._children[childIdx], refFeature);
        return result;
    };
    Node.fromString = function(string) {
        var node = JSON.parse(string);
        var result = new Node(node.name, node.children, node.feature, node.leaf, node.mapping, node.hidden);
        result._children = node._children;
        for (childIdx in result.getChildren()) result.children[childIdx] = Node.fromString(result.children[childIdx]);
        for (childIdx in result.get_Children()) result._children[childIdx] = Node.fromString(result._children[childIdx]);
        return result;
    };
    return Node;
} ]);

angular.module("graphs").directive("forceLayoutDirective", function() {
    function link(scope, element, attrs) {
        //DOM appending
        var container = element[0];
        var zoom = d3.behavior.zoom().scaleExtent([ .1, 10 ]).on("zoom", zoomed);
        var svg = d3.select(container).append("svg");
        var zoomCtrl = svg.append("g").call(zoom);
        var rect = zoomCtrl.append("rect");
        var zoomable = zoomCtrl.append("g");
        var linkGroup = zoomable.append("g");
        var nodeGroup = zoomable.append("g");
        var defs = linkGroup.append("svg:defs");
        function zoomed() {
            //if (d3.event.defaultPrevented) return;
            zoomable.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
        }
        var force = d3.layout.force();
        //Call this method to display the graph
        function update() {
            var nodes = scope.nodes ? scope.nodes : [];
            var links = scope.links ? scope.links : [];
            //behavior for the color / title and so on.
            var radiusDlg = scope.radiusDlg ? scope.radiusDlg : function(d) {
                return 5;
            };
            var fillDlg = scope.fillDlg ? scope.fillDlg : function(d) {
                return 1;
            };
            var titleDlg = scope.titleDlg ? scope.titleDlg : function(d) {
                return d.toString();
            };
            var textDlg = scope.textDlg ? scope.textDlg : function(d) {
                return d.toString();
            };
            var nodeOpacity = scope.nodeOpacityDlg ? scope.nodeOpacityDlg : function(d) {
                return .5;
            };
            var linkOpacity = scope.linkOpacityDlg ? scope.linkOpacityDlg : function(d) {
                return 1;
            };
            // var colorScale = d3.scale.linear().range(["#fff", "#a50026"]).domain([0, d3.max(nodes, fillDlg)]);
            var colorScale = d3.scale.category10();
            var radiusScale = d3.scale.linear().range([ 0, 5, 30 ]).domain([ 0, 1, d3.max(nodes, radiusDlg) ]);
            //updating the size of the DOM
            var containerSize = element.parent().width();
            var containerHeight = element.parent().height();
            svg.attr("width", containerSize).attr("height", containerSize);
            rect.attr("width", containerSize).attr("height", containerSize).style("fill", "none").style("pointer-events", "visible").style("cursor", "all-scroll");
            force.size([ containerSize, containerSize ]);
            //Bootstraping the d3.force
            force.nodes(nodes).links(links).linkDistance(50).charge(-300).start();
            //building the links
            var link = linkGroup.selectAll(".link").data(links);
            link.enter().append("path").attr("class", "link");
            link.exit().remove();
            //building the nodes
            var node = nodeGroup.selectAll(".node").data(nodes);
            var newNodes = node.enter().append("g").attr("class", "node").call(force.drag).on("mousedown", function() {
                d3.event.stopPropagation();
            });
            newNodes.append("circle");
            newNodes.append("text");
            node.exit().remove();
            //change the style by calling the delegates
            function redraw() {
                node.select("circle").transition(1).attr("r", function(d) {
                    return radiusScale(radiusDlg(d));
                }).style("fill", function(d) {
                    return colorScale(fillDlg(d));
                });
                node.select("text").transition(1).style("text-anchor", "middle").style("-webkit-user-select", "none").style("-moz-user-select", "none").style("-ms-user-select", "none").style("stroke-width", "3px").style("fill", "#444").text(textDlg);
                newNodes.transition(1).style("opacity", function(d) {
                    return nodeOpacity(d);
                });
                link.style("fill", "none").transition(1).style("stroke", "#999").style("opacity", function(d) {
                    return linkOpacity(d);
                });
            }
            redraw();
            node.on("mouseover", function(d) {
                if (scope.hovered !== undefined) {
                    scope.$apply(function() {
                        scope.tooltipShow = true;
                        scope.x = d3.event.offsetX;
                        scope.y = d3.event.offsetY;
                        scope.hovered = d;
                    });
                    scope.$evalAsync(function() {
                        redraw();
                    });
                }
            }).on("mouseout", function(d) {
                if (scope.hovered !== undefined) {
                    scope.$apply(function() {
                        scope.tooltipShow = false;
                        scope.hovered = null;
                    });
                    scope.$evalAsync(function() {
                        redraw();
                    });
                }
            }).on("click", function(d) {
                if (scope.clicked !== undefined) {
                    scope.$apply(function() {
                        if (scope.clicked == d) scope.clicked = null; else scope.clicked = d;
                    });
                    scope.$evalAsync(function() {
                        redraw();
                    });
                }
            });
            if (scope.directed) {
                var arrows = defs.selectAll("marker").data(force.links());
                arrows.enter().append("svg:marker");
                arrows.exit().remove();
                link.attr("marker-end", function(d, idx) {
                    if (scope.directed) return "url(#marker-" + idx + ")";
                });
                arrows.attr("id", function(d, idx) {
                    return "marker-" + idx;
                }).attr("viewBox", "0 -5 10 10").attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", "auto").append("svg:path").attr("d", "M0,-5L10,0L0,5").attr("fill", "#999");
            }
            //update the position of the elements
            var tick = 0;
            force.on("tick", function() {
                tick = (tick + 1) % 100;
                if (scope.directed) {
                    var arrows = defs.selectAll("marker").data(force.links());
                    arrows.attr("refX", function(d) {
                        //return the length of the marker view box 
                        // + the ration between the viewBox and the marker size
                        // times the radius of the target
                        return 10 + 10 / 6 * radiusScale(radiusDlg(d.target));
                    }).attr("refY", function(d) {
                        var offset = 6 + radiusScale(radiusDlg(d.target));
                        var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy);
                        var offsetRatio = 2 * offset / dr;
                        // percentage of h offset.
                        //the formula is here : https://fr.wikipedia.org/wiki/Segment_circulaire
                        //theta = 1 radian
                        var h = dr * (1 - Math.cos(.5));
                        //todo : not quite good
                        return 10 / 6 * -offsetRatio;
                    });
                }
                link.attr("d", function(d) {
                    var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy);
                    return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1" + d.target.x + "," + d.target.y;
                });
                node.attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });
            });
        }
        scope.$watch("resize + nodes + nodeOpacityDlg", function(value) {
            update();
        }, true);
    }
    return {
        restrict: "E",
        scope: {
            nodes: "=",
            //node element displayed as a circle with hover or, as a text
            links: "=",
            //links = [{source: idx, target:idx}]
            radiusDlg: "=",
            //function returning the radius of the node, given the node. the radius is then normalised. default is returning 1
            fillDlg: "=",
            //function returning the color intensity of the node, given the node. the color indice is then normalised. default is returning 1.
            titleDlg: "=",
            //not used
            textDlg: "=",
            //function returning the text over the node. default is calling to string.
            nodeOpacityDlg: "=",
            //function returning the opacity of the object (0 to 1).
            linkOpacityDlg: "=",
            //same as nodeOpacityDlg.
            directed: "=",
            //true or false: the links are directed
            legend: "=",
            //
            hovered: "=",
            clicked: "="
        },
        transclude: true,
        link: link,
        template: function(elem, attrs) {
            var template = "<tooltip-directive show='tooltipShow' x='x' y='y'>";
            template += attrs.template ? attrs.template : "<div class='panel panel-default'><ng-transclude></ng-transclude></div>";
            return template += "</tooltip-directive>";
        }
    };
});

angular.module("graphs").directive("pieChartDirective", [ "$window", "clusterProvider", function($window, clusterProvider) {
    function link(scope, element, attrs) {
        var container = element[0];
        var svg = d3.select(container).append("svg");
        var g = svg.append("g");
        var tooltip = d3.select("body").append("div").attr("class", "pieTooltip").style("opacity", 0);
        function update() {
            if (!scope.values) return;
            var data = clusterProvider.groupByOrder(scope.values, 40);
            var width = element.parent().width(), height = element.parent().width(), radius = Math.min(width, height) / 4;
            var arc = d3.svg.arc().outerRadius(radius - 10).innerRadius(0);
            var outerArc = d3.svg.arc().innerRadius(radius).outerRadius(radius);
            var pie = d3.layout.pie().value(function(d, i) {
                return clusterProvider.getSumValue(d, "support");
            });
            svg.attr("width", width).attr("height", height);
            g.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
            var path = g.selectAll(".arc").data(pie(data));
            path.enter().append("path").attr("class", "arc");
            path.transition().duration(1e3).style({
                fill: function(d) {
                    return clusterProvider.getMiddleValue(d.data, "color");
                },
                opacity: .8
            }).attr("d", function(d) {
                return arc(d);
            });
            //.transition().duration(1000)
            //.attrTween("d", function (d) {
            //    this._current = this._current || d;
            //    var interpolate = d3.interpolate(this._current, d);
            //    this._current = interpolate(0);
            //    return function (t) {
            //        return arc(interpolate(t));
            //    };
            //});
            path.on("mouseover", function(d) {
                scope.hovered.set(d.data);
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(clusterProvider.getFirstAndLastValue(d.data, "value") + "<br/>" + clusterProvider.getSumValue(d.data, "support")).style("left", d3.event.pageX + "px").style("top", d3.event.pageY + "px");
            });
            path.on("click", function(d) {
                scope.selected.toggle(d.data);
            }).on("mouseout", function(d) {
                scope.hovered.set(null);
                tooltip.transition().duration(200).style("opacity", 0);
            });
            path.exit().remove();
            var text = g.selectAll(".text").data(pie(data));
            text.enter().append("text").attr("class", "text");
            text.attr("dy", ".35em").attr("style", "fill:white;").text(function(d) {
                return clusterProvider.getFirstAndLastValue(d.data, "value");
            });
            text.transition().duration(1e3).attrTween("transform", function(d) {
                this._current = this._current || d;
                var interpolate = d3.interpolate(this._current, d);
                this._current = interpolate(0);
                return function(t) {
                    var d2 = interpolate(t);
                    var pos = outerArc.centroid(d2);
                    pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
                    return "translate(" + pos + ")";
                };
            }).styleTween("text-anchor", function(d) {
                this._current = this._current || d;
                var interpolate = d3.interpolate(this._current, d);
                this._current = interpolate(0);
                return function(t) {
                    var d2 = interpolate(t);
                    return midAngle(d2) < Math.PI ? "start" : "end";
                };
            });
            text.exit().remove();
        }
        function midAngle(d) {
            return d.startAngle + (d.endAngle - d.startAngle) / 2;
        }
        angular.element($window).bind("resize", function() {
            update();
        });
        scope.$watch("values", function(value) {
            update();
        }, true);
        scope.$watch("selected.get()", function(value) {
            svg.selectAll(".arc").transition().duration(200).style("fill", function(d) {
                return scope.selected.contains(d.data) ? "red" : clusterProvider.getMiddleValue(d.data, "color");
            });
        }, true);
        scope.$watch("hovered.get()", function(value) {
            svg.selectAll(".arc").transition().duration(200).style("opacity", function(d) {
                return scope.hovered.contains(d.data) ? 1 : .8;
            });
        }, true);
        //need to display arcs after the vie is changed
        //todo better solution?
        setTimeout(update, 1e3);
    }
    return {
        restrict: "E",
        scope: {
            values: "=values",
            //should be an array of {value: string, support: int, color: hex}
            selected: "=selected",
            hovered: "=emphasized",
            addWhere: "=addWhere"
        },
        link: link
    };
} ]);

angular.module("graphs").directive("pointCloudDirective", [ "$window", "clusterProvider", function($window, clusterProvider) {
    function link(scope, element, attrs) {
        var container = element[0];
        var svg = d3.select(container).append("svg");
        var g = svg.append("g");
        var domXAxis = g.append("g");
        var domYAxis = g.append("g");
        var yLabel = g.append("text");
        var tooltip = d3.select("body").append("div").attr("class", "circleTooltip").style("opacity", 0);
        function update() {
            if (!scope.values) return;
            var data = clusterProvider.groupByOrder(scope.values, 19);
            var containerSize = element.parent().width();
            //-----DOM-----
            var margin = {
                top: 20,
                right: 20,
                bottom: 70,
                left: 50
            }, width = containerSize - margin.left - margin.right, height = containerSize - margin.top - margin.bottom;
            var x = d3.scale.ordinal().rangeRoundBands([ 0, width ], .05);
            var y = d3.scale.linear().range([ height, 0 ]);
            var xAxis = d3.svg.axis().scale(x).orient("bottom");
            var yAxis = d3.svg.axis().scale(y).orient("left");
            svg.attr("width", width + margin.left + margin.right).attr("height", containerSize);
            g.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
            domXAxis.attr("class", "x axis").attr("transform", "translate(0," + height + ")");
            domYAxis.attr("class", "y axis");
            yLabel.transition().duration(1e3).attr("transform", "rotate(-90)").attr("y", 0 - margin.left).attr("x", 0 - height / 2).attr("dy", "1em").style("text-anchor", "middle").text("Support");
            x.domain(data.map(function(d) {
                return clusterProvider.getFirstAndLastValue(d, "value");
            }));
            y.domain([ 0, d3.max(data, function(d) {
                return clusterProvider.getSumValue(d, "support");
            }) ]);
            var textX = domXAxis.transition().duration(1e3).call(xAxis);
            if (data.length > 10) {
                textX.selectAll("text").style("text-anchor", "end").attr("dx", "-.8em").attr("dy", ".15em").attr("transform", function(d) {
                    return "rotate(-65)";
                });
            }
            domYAxis.transition().duration(1e3).call(yAxis);
            //-----DATA-----
            var circles = g.selectAll(".circle").data(data);
            circles.enter().append("circle").attr("class", "circle");
            circles.exit().remove();
            circles.transition().duration(1e3).style("fill", function(d) {
                return clusterProvider.getMiddleValue(d, "color");
            }).attr("cx", function(d) {
                return x(clusterProvider.getFirstAndLastValue(d, "value"));
            }).attr("r", x.rangeBand() / 2).attr("cy", function(d) {
                return y(clusterProvider.getSumValue(d, "support"));
            }).attr("height", function(d) {
                return height - y(clusterProvider.getSumValue(d, "support"));
            });
            circles.on("mouseover", function(d) {
                scope.hovered.set(d);
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(clusterProvider.getFirstAndLastValue(d, "value") + "<br/>" + clusterProvider.getSumValue(d, "support")).style("left", d3.event.pageX + "px").style("top", d3.event.pageY + "px");
            }).on("mouseout", function(d) {
                scope.hovered.set(null);
                tooltip.transition().duration(200).style("opacity", 0);
            }).on("click", function(d) {
                scope.selected.toggle(d);
            }).on("dblclick", function(d) {});
        }
        angular.element($window).bind("resize", function() {
            update();
        });
        scope.$watch("values", function(value) {
            update();
        }, true);
        scope.$watch("selected.get()", function(value) {
            svg.selectAll(".circle").transition().duration(200).style("fill", function(d) {
                return scope.selected.contains(d) ? "red" : clusterProvider.getMiddleValue(d, "color");
            });
        }, true);
        scope.$watch("hovered.get()", function(value) {
            svg.selectAll(".circle").transition().duration(200).style("opacity", function(d) {
                return scope.hovered.contains(d) ? 1 : .8;
            });
        }, true);
        //need to display bars after the vie is changed
        //todo better solution?
        setTimeout(update, 1e3);
    }
    return {
        restrict: "E",
        scope: {
            values: "=values",
            //should be an array of {value: string, support: int, color: hex}
            selected: "=selected",
            hovered: "=emphasized"
        },
        link: link
    };
} ]);

/**
 * @ngdoc directive
 * @name graphs.views.tooltipDirective
 * @description Display a transcluding tooltip at the specified position.
 *
 */
angular.module("graphs").directive("tooltipDirective", function() {
    function link(scope, element, attrs) {
        var container = element[0];
        var tooltip = d3.select(container).attr("class", "tooltip").style("opacity", 0).style("position", "absolute");
        function update() {
            if (scope.show) {
                //element.context.parentNode.style.cursor = 'pointer';
                tooltip.transition().duration(200).style("opacity", .9).style("pointer-events", "auto").style("left", scope.x + "px").style("top", scope.y + "px");
            } else {
                //element.context.parentNode.style.cursor = cursor;
                tooltip.transition().duration(200).style("pointer-events", "none").style("opacity", 0);
            }
        }
        scope.$watch(function() {
            return {
                show: scope.show,
                x: scope.x,
                y: scope.y,
                update: scope.update
            };
        }, update, true);
    }
    return {
        restrict: "E",
        scope: {
            show: "=",
            update: "=?",
            x: "=",
            y: "="
        },
        transclude: true,
        template: "<ng-transclude></ng-transclude>",
        link: link
    };
});

angular.module("language").directive("languageFormDirective", [ "speechToTextService", "textRecognitionService", function(speechToTextService, textRecognitionService) {
    function link(scope, element, attrs) {
        var speechToText = new speechToTextService();
        speechToText.SetOnResultDlg(function(event) {
            scope.$apply(function() {
                scope.userInput = event.results[0][0].transcript;
            });
        });
        speechToText.SetOnEndDlg(function() {
            scope.$apply(function() {
                scope.isRecording = false;
            });
        });
        speechToText.SetOnStartDlg(function() {
            scope.$apply(function() {
                scope.isRecording = true;
            });
        });
        scope.record = function() {
            if (scope.isRecording) {
                speechToText.Stop();
            } else {
                speechToText.Start();
            }
        };
    }
    return {
        restrict: "E",
        scope: {
            userInput: "="
        },
        templateUrl: function(elem, attrs) {
            return "app/shared/language/views/languageForm.html";
        },
        link: link
    };
} ]);

angular.module("language").factory("speechToTextService", [ function() {
    var service = function() {
        var recognition = new webkitSpeechRecognition();
        recognition.lang = "en-US";
        this.Start = function() {
            recognition.start();
        };
        this.Stop = function() {
            recognition.stop();
        };
        this.SetOnResultDlg = function(dlg) {
            recognition.onresult = dlg;
        };
        this.SetOnErrorDlg = function(dlg) {
            recognition.onerror = dlg;
        };
        this.SetOnEndDlg = function(dlg) {
            recognition.onend = dlg;
        };
        this.SetOnStartDlg = function(dlg) {
            recognition.onstart = dlg;
        };
    };
    return service;
} ]);

angular.module("language").controller("TextRecognitionController", [ "$scope", "$http", function($scope, $http) {
    $scope.utterances = [ "Ios", "nexus 4 os", "what is the os of the nexus 4 ?", "price nexus 5", "most expensive phone", //"most expensive phones",
    //"phones with a 4G antenna",
    "phones with a USB connectivity", //"results done with SFR as an operator",
    "phone available before 2014", "phone with USB connectivity and assisted GPS connectivity", //"phone with a camera or a GPS",
    "number of phone", "phones with at least 3 connectivity" ];
    $scope.lispToJson = function(tree) {
        var parser = new littleLisp();
        var json = parser.Parse(tree);
        return json;
    };
    $scope.$watch("utterance", function(value) {
        $http.get("http://7h5vxw1:8400/sempre", {
            headers: {},
            params: {
                q: value,
                format: "json"
            }
        }).success(function(response, textStatus, headers, config) {
            // for(var i in response.candidates){
            //        response.candidates[i].value = $scope.lispToJson(response.candidates[i].value);
            //    }
            $scope.denotations = response;
        }).error(function() {});
    });
} ]);

angular.module("language").directive("textRecognitionDirective", function() {
    function link(scope, element, attrs) {}
    return {
        restrict: "E",
        templateUrl: "app/shared/language/textRecognition/textRecognition.html",
        link: link
    };
});

angular.module("language").factory("textRecognitionService", function() {
    return function() {
        //object on the form: 
        // { scenarriName: { regex: /str/i, (remplace: "substitutionStr") } s
        this.Scenarii = {};
        this.SplitRegex = /([\|,;]+|and)/gi;
        this.Tag = function(text) {
            var tokens = nlp.pos(text).sentences[0].tokens;
            var result = [];
            for (var scenarioIt in this.scenarii) {
                var scenario = this.scenarii[scenarioIt];
                var scenarioValidated = true;
                for (var ruleIt in scenario) {
                    var rule = scenario[ruleIt];
                    var ruleValidated = false;
                    for (var tokenIt in tokens) {
                        var token = tokens[tokenIt];
                        if (rule.indexOf(token.normalised) != -1) {
                            ruleValidated = true;
                            break;
                        }
                    }
                    if (!ruleValidated) {
                        scenarioValidated = false;
                        break;
                    }
                }
                if (scenarioValidated) result.push(scenario);
            }
            return result;
        };
        //return the scenarii found in the text
        this.match = function(text) {
            var results = [];
            var sentences = text.split(this.SplitRegex);
            for (var sentenceIt in sentences) {
                var sentence = sentences[sentenceIt];
                for (var scenarioIt in this.Scenarii) {
                    var scenario = this.Scenarii[scenarioIt].rule;
                    var scenarioValidated = true;
                    var result = [];
                    for (var ruleIt in scenario) {
                        var rule = scenario[ruleIt];
                        var ruleValidated = false;
                        var res = sentence.match(rule.regex);
                        if (res && res[0]) {
                            if (rule.remplace !== undefined) result.push(rule.remplace); else result.push(res[0]);
                            ruleValidated = true;
                        }
                        if (!ruleValidated) {
                            scenarioValidated = false;
                            break;
                        }
                    }
                    if (scenarioValidated) {
                        results.push({
                            type: this.Scenarii[scenarioIt].type,
                            rule: result
                        });
                    }
                }
            }
            return results;
        };
        // Return position of last char of s (string) in str (string)
        // If s is not in str, return null
        var positionOfSubstring = function(str, s) {
            var start = str.indexOf(s);
            if (start != -1) {
                return start + s.length;
            } else {
                return null;
            }
        };
        // Return an array of all element into a string after next word of target word
        // ex : "My cat is blue", if "cat" is the target => return [{name:blue, start:startPosition, end:endPosition}]
        this.FindWordAfterTarget = function(str, target) {
            var num = positionOfSubstring(str, target);
            if (num === null) {
                return;
            }
            strSub = str.substr(num).trim();
            num = positionOfSubstring(strSub, " ");
            strSub = strSub.substr(num);
            strSubArray = strSub.trim().split("&").join("and").split(",").join(" and").split(" and ");
            for (i in strSubArray) {
                var tmpPos = positionOfSubstring(str, strSubArray[i]);
                strSubArray[i] = {
                    name: strSubArray[i],
                    start: tmpPos - strSubArray[i].length,
                    end: tmpPos
                };
            }
            return strSubArray;
        };
    };
});

/*
	Speech Synthesis API Angular Module
	http://updates.html5rocks.com/2014/01/Web-apps-that-talk---Introduction-to-the-Speech-Synthesis-API
*/
angular.module("language").factory("textToSpeechService", [ function() {
    // Create a new instance of SpeechSynthesisUtterance.
    this.SpeechSU = new SpeechSynthesisUtterance();
    this.ReadText = function(string, callback) {
        // Set the text.
        this.SpeechSU.text = string;
        // Queue this utterance.
        speechUtteranceChunker(this.SpeechSU, {}, callback);
    };
    var speechUtteranceChunker = function(utt, settings, callback) {
        settings = settings || {};
        var newUtt;
        var txt = settings && settings.offset !== undefined ? utt.text.substring(settings.offset) : utt.text;
        if (utt.voice && utt.voice.voiceURI === "native") {
            // Not part of the spec
            newUtt = utt;
            newUtt.text = txt;
            newUtt.addEventListener("end", function() {
                if (speechUtteranceChunker.cancel) {
                    speechUtteranceChunker.cancel = false;
                }
                if (callback !== undefined) {
                    callback();
                }
            });
        } else {
            speechSynthesis.cancel();
            var chunkLength = settings && settings.chunkLength || 160;
            var pattRegex = new RegExp("^[\\s\\S]{" + Math.floor(chunkLength / 2) + "," + chunkLength + "}[.!?,]{1}|^[\\s\\S]{1," + chunkLength + "}$|^[\\s\\S]{1," + chunkLength + "} ");
            var chunkArr = txt.match(pattRegex);
            if (!chunkArr) {
                return;
            }
            if (chunkArr[0] === undefined || chunkArr[0].length <= 2) {
                //call once all text has been spoken...
                if (callback !== undefined) {
                    callback();
                }
                return;
            }
            var chunk = chunkArr[0];
            newUtt = new SpeechSynthesisUtterance(chunk);
            var x;
            for (x in utt) {
                if (utt.hasOwnProperty(x) && x !== "text") {
                    newUtt[x] = utt[x];
                }
            }
            newUtt.addEventListener("end", function() {
                if (speechUtteranceChunker.cancel) {
                    speechUtteranceChunker.cancel = false;
                    return;
                }
                settings.offset = settings.offset || 0;
                settings.offset += chunk.length - 1;
                speechUtteranceChunker(utt, settings, callback);
            });
        }
        if (settings.modifier) {
            settings.modifier(newUtt);
        }
        console.log(newUtt);
        //IMPORTANT!! Do not remove: Logging the object out fixes some onend firing issues.
        //placing the speak invocation inside a callback fixes ordering and onend issues.
        setTimeout(function() {
            speechSynthesis.speak(newUtt);
        }, 0);
    };
    this.StopText = function() {
        speechSynthesis.cancel();
    };
    return this;
} ]);

angular.module("utils").factory("addslashes", function() {
    return function(string) {
        return string.replace(/\\/g, "\\\\").replace(/\u0008/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/'/g, "\\'").replace(/"/g, '\\"');
    };
});

angular.module("utils").factory("cancellableHttpService", [ "$http", "$q", "copyService", function($http, $q, copyService) {
    return function() {
        var canceller;
        var cancel = function(reason) {
            canceller.resolve(reason);
            pending = false;
        };
        var pending = false;
        this.getPending = function() {
            return pending;
        };
        var lastError;
        this.getLastError = function() {
            return error;
        };
        var lastReq;
        var lastSuccess;
        var lastError;
        var promise;
        // wrapper of the $http.get service.
        //needs 
        // var req = {
        // 	method : method ? method : 'GET',
        // 	url : url,
        // 	headers : headers,
        // 	data: data (javascript object for post request)
        //  params : params (javascript object encoded in the URL)
        // };
        //success and error delegates
        //returns a cancel function;
        // If a request is already pending (myCancellableHttpService.getPending()), this method will check if the url and the options are the same and cancel the oldRequest. 
        // it also keep the answer, and if the result flag deterministic is on, it will not query again and return the oldResult
        //becareful, if the flag is false, and the request is binded to html, a apply is called by the http service automatically and creating a loop !
        this.request = function(req, successDlg, errorDlg, deterministicResult) {
            if (pending) {
                if (!deterministicResult || !angular.equals(req, lastReq)) {
                    cancel("new request pending");
                } else {
                    return cancel;
                }
            } else if (deterministicResult && angular.equals(req, lastReq)) {
                if (lastSuccess) successDlg(lastSuccess); else if (lastError) errorDlg(lastError);
                return cancel;
            }
            pending = true;
            canceller = $q.defer();
            lastReq = copyService.shallow(req);
            lastError = undefined;
            lastSuccess = undefined;
            if (!req.options) {
                req.options = {};
            }
            req.options.timeout = canceller.promise;
            if (!req.method) {
                req.method = "GET";
            }
            //TODO: can the req finish before the callback is setup ? use the then function ?
            var wrappedPromise = $http(req).then(function(response) {
                pending = false;
                lastSuccess = response.data;
                successDlg(response.data);
            }, function(response) {
                pending = false;
                lastError = response;
                errorDlg(response);
            });
            // var wrappedPromise = $http(req);
            // promise = { 
            // 	success: function(dlg){
            // 		wrappedPromise.success(function(data){
            // 			pending = false;
            // 			lastSuccess = data;
            // 			dlg(data);
            // 		});
            // 	},
            // 	error: function(dlg){
            // 		wrappedPromise.error(function(data){
            // 			pending = false;
            // 			lastError = data;
            // 			dlg(data);
            // 		});
            // 	},
            // 	cancel: cancel 
            // };
            return cancel;
        };
    };
} ]);

angular.module("utils").filter("compress", [ "$filter", function($filter) {
    function roundToN(num, n) {
        return +(Math.round(num + "e+" + n) + "e-" + n);
    }
    return function(value, maxN) {
        if (!maxN || maxN < 1) maxN = 10;
        var strValue = value.toString();
        var length = strValue.length;
        if (length < maxN) return value;
        var nbrValue = Number(value);
        if (nbrValue) {
            var integerLength = Math.trunc(nbrValue).toString().length;
            if (nbrValue > Math.pow(10, maxN)) {
                nbrValue = nbrValue / Math.pow(10, integerLength - 1);
                nbrValue = $filter("number")(nbrValue, maxN - 1);
                return nbrValue.toString() + "e" + (integerLength - 1).toString();
            } else {
                nbrValue = $filter("number")(nbrValue, maxN - integerLength);
                return nbrValue;
            }
        } else {
            return strValue.substring(0, maxN - 3) + "...";
        }
    };
} ]);

angular.module("utils").factory("copyService", function() {
    this.shallow = function(oldObj) {
        var newObj = {};
        for (var i in oldObj) {
            if (oldObj.hasOwnProperty(i)) {
                newObj[i] = oldObj[i];
            }
        }
        return newObj;
    };
    return this;
});

angular.module("utils").directive("disableAnimation", [ "$animate", function($animate) {
    return {
        restrict: "A",
        link: function($scope, $element, $attrs) {
            $attrs.$observe("disableAnimation", function(value) {
                $animate.enabled(!value, $element);
            });
        }
    };
} ]);

angular.module("utils").filter("duration", function() {
    pad = function(str, max) {
        str = str.toString();
        return str.length < max ? pad("0" + str, max) : str;
    };
    return function(milli) {
        milli = milli || 0;
        var milliseconds = milli % 1e3;
        var seconds = Math.floor(milli / 1e3 % 60);
        var minutes = Math.floor(milli / (60 * 1e3) % 60);
        var hours = Math.floor(milli / (60 * 60 * 1e3));
        if (!minutes) minutes = "00";
        return pad(hours, 2) + "h " + pad(minutes, 2) + "m";
    };
});

angular.module("utils").directive("circularSelectDirective", [ "$http", "asynchronousService", function($http, asynchronousService) {
    function link(scope, element, attrs) {
        //style
        var container = element[0];
        scope.active = false;
        if (!angular.element("link.circularSelect").length) {
            angular.element("head").append('<link class="circularSelect" href="app/shared/utils/form/circularSelect/circularSelect.css" rel="stylesheet">');
        }
        scope.$watch("options", function(options) {
            if (!options) return;
            var n = Object.keys(options).length;
            var frequency = Math.PI * 2 / n;
            var radius = scope.radius || 200;
            var i = 0;
            for (var key in options) {
                var angleRad = i * frequency;
                var y = Math.sin(angleRad);
                var x = Math.cos(angleRad);
                options[key].style = "transform: translate3d(" + Math.floor(radius * x) + "px, " + Math.floor(radius * y) + "px, 0);";
                i++;
            }
            element.container.style = "height : " + radius * 2 + "px;";
        });
        //interactions
        // close the select element if the target it´s not the select element or one of its descendants..
        // so we have to stop propagation on the other click events to prevent this one
        document.addEventListener("click", function(ev) {
            scope.$apply(function() {
                //document.addEvent is not an angular function. so we have to call scope.$apply to check others scope.$watch
                scope.active = false;
            });
        });
        scope.submit = function(event) {
            event.stopPropagation();
            scope.active = !scope.active;
            if (!scope.active && scope.submitCallback) {
                var result = {};
                for (var i in scope.options) {
                    if (scope.options[i].select) result[i] = scope.options[i];
                }
                scope.submitCallback(result);
            }
        };
        scope.select = function(event, option) {
            event.stopPropagation();
            if (!scope.multiple) {
                for (var i in scope.options) {
                    scope.options[i].select = false;
                }
                option.select = true;
                scope.active = false;
                return;
            }
            option.select = !option.select;
        };
    }
    return {
        restrict: "E",
        scope: {
            options: "=",
            //array of objects with a label displayed in the options
            multiple: "=?",
            //checkBox or radio(default) button behavior ?
            radius: "=?",
            //offset ,default to 200px, around tu button. (notice that The elements are tacking the size of the element transcluded)
            submitCallback: "=?"
        },
        transclude: "true",
        templateUrl: "app/shared/utils/form/circularSelect/circularSelectTemplate.html",
        link: link
    };
} ]);

angular.module("utils").directive("datePickerDirective", [ "$http", "$rootScope", "asynchronousService", function($http, $rootScope, asynchronousService) {
    function link(scope, element, attrs) {
        var container = element[0];
        //scope.ngModel = new Date();
        scope.dateOpened = false;
        scope.showWeeks = false;
        scope.dateOptions = {
            formatYear: "yy",
            startingDay: 1,
            showWeeks: "false"
        };
        //timePicker opening
        scope.open = function($event) {
            scope.$apply(function() {
                $event.preventDefault();
                $event.stopPropagation();
                scope.dateOpened = !scope.dateOpened;
            });
        };
        scope.$watch("dateOpened", function(newValue, oldValue) {
            $rootScope.$broadcast("openDatePicker", newValue);
        });
        element.bind("click", scope.open);
    }
    return {
        restrict: "AE",
        scope: {
            ngModel: "=",
            ngRequired: "=",
            closeText: "=",
            initDate: "=",
            minDate: "=",
            maxDate: "=",
            realName: "=",
            statusScale: "=?"
        },
        templateUrl: "app/shared/utils/form/datePicker/datePickerTemplate.html",
        link: link
    };
} ]);

angular.module("utils").directive("progressButtonDirective", [ "$timeout", function($timeout) {
    function link(scope, element, attrs) {
        //annimations
        if (!angular.element("link.progressButton").length) {
            angular.element("head").append('<link class="progressButton" href="app/shared/utils/form/progressButton/progressButton.css" rel="stylesheet">');
        }
        var buttonEl = [].slice.call(element.find("button"));
        var progressEl = [].slice.call(element.find(".progress-circle path"));
        var successEl = [].slice.call(element.find(".checkmark path"));
        var errorEl = [].slice.call(element.find(".cross path"));
        var paths = [].slice.call(element.find("path"));
        paths.forEach(function(path, i) {
            path.style.transition = "all cubic-bezier(0.7, 0, 0.3, 1) 0.5s";
            var length = path.getTotalLength();
            path.style.strokeDasharray = length + " " + length;
        });
        var offsetPath = function(pathArray, draw) {
            pathArray.forEach(function(path, i) {
                if (!draw) {
                    var length = path.getTotalLength();
                    path.style.strokeDashoffset = length;
                } else {
                    path.style.strokeDashoffset = "0px";
                }
            });
        };
        scope.$watch("status", function(status) {
            offsetPath(paths, false);
            if (status == "loading") offsetPath(progressEl, true); else if (status == "success") offsetPath(successEl, true); else if (status == "error") offsetPath(errorEl, true);
        });
        //interaction
        if (!scope.status || scope.status == "") scope.status = "idle";
        scope._submit = function($event) {
            if (!scope.submit) return;
            scope.status = "loading";
            scope.submit(successDlg, errorDlg);
        };
        var successDlg = function(data) {
            scope.status = "success";
            $timeout(function() {
                scope.status = "idle";
            }, 2e3);
        };
        var errorDlg = function(data) {
            scope.status = "error";
            $timeout(function() {
                scope.status = "idle";
            }, 2e3);
        };
    }
    return {
        restrict: "E",
        scope: {
            submit: "=?",
            //(optional) function(succesCallback, errorCallback), called if specified when clicking on the button
            status: "=?"
        },
        transclude: "true",
        templateUrl: "app/shared/utils/form/progressButton/progressButtonTemplate.html",
        link: link
    };
} ]);

angular.module("utils").directive("selectNumberDirective", [ "$http", "$rootScope", "$timeout", "asynchronousService", function($http, $rootScope, $timeout, asynchronousService) {
    function link(scope, element, attrs) {
        function addCSS() {
            if (!angular.element("link#selectNumberCSS").length) {
                angular.element("head").append('<link id="selectNumberCSS" href="app/shared/utils/form/selectnumber/selectNumber.css" rel="stylesheet">');
            }
        }
        addCSS();
        // Construct array from min to max.
        scope.getNumber = function(min, max) {
            a = new Array(max - min + 1);
            for (i = 0; i < a.length; i++) {
                a[i] = min + i;
            }
            return a;
        };
        scope.changeSelectModel = function(value, event) {
            scope.selectModel = value;
        };
        scope.movePosition = function(index) {};
        // Compute height of element
        scope.$watchGroup([ "minValue", "maxValue" ], function() {
            addCSS();
            var main = $(".select-number-main");
            var num = $(".select-number-value");
            // height = num height + 2* padding + font-size
            $timeout(function() {
                var fontSize = num.css("font-size").replace("px", "") || 0;
                var paddingSize = num.css("padding") || 0;
                var heightSize = parseInt(num.height()) || 0;
                var totalHeight = parseInt(fontSize) + parseInt(paddingSize) + heightSize;
                main.height(totalHeight);
            }, 100);
        });
    }
    return {
        restrict: "AE",
        scope: {
            minValue: "=?",
            maxValue: "=?",
            selectModel: "=?"
        },
        templateUrl: "app/shared/utils/form/selectnumber/selectNumberTemplate.html",
        link: link
    };
} ]);

angular.module("utils").directive("tabsetDirective", [ "$timeout", function($timeout) {
    function link(scope, element, attrs) {
        scope.selectedIndex = 0;
        scope.selectIndex = function(index) {
            if (index == scope.selectedIndex) return;
            if (index > scope.selectedIndex) {
                //we go to the right, so we move everything to the left
                scope.tabs[index].class = "animate-slide animate-slide-right";
                scope.tabs[scope.selectedIndex].class = "animate-slide animate-slide-left";
            }
            if (index < scope.selectedIndex) {
                //move to the left
                scope.tabs[index].class = "animate-slide animate-slide-left";
                scope.tabs[scope.selectedIndex].class = "animate-slide animate-slide-right";
            }
            $timeout(function() {
                scope.selectedIndex = index;
            });
        };
    }
    return {
        restrict: "E",
        scope: {
            tabs: "="
        },
        templateUrl: "app/shared/utils/form/tabset/tabsetTemplate.html",
        link: link
    };
} ]);

angular.module("utils").directive("iframeOnload", [ function() {
    return {
        scope: {
            callBack: "=iframeOnload"
        },
        link: function(scope, element, attrs) {
            element.on("load", function() {
                return scope.callBack(element);
            });
            scope.$on("$destroy", function() {
                element.off("load");
            });
        }
    };
} ]);

angular.module("utils").factory("jobQueueService", [ "$timeout", "$q", function($timeout, $q) {
    //to handle error and so on
    this.Progress = function() {
        var label = "";
        this.setLabel = function(text) {
            label = text;
        };
        this.getLabel = function() {
            return label;
        };
        var percent = 0;
        this.setPercent = function(num) {
            if (num > 100) {
                num = 100;
            } else if (num < 0) {
                num = 0;
            }
            percent = num;
            if (percent == 100) isRunning = false; else isRunning = true;
        };
        this.getPercent = function() {
            return percent;
        };
        var isRunning = false;
        this.isRunning = function() {
            return isRunning;
        };
    };
    this.Queue = function() {
        var that = this;
        var position = 0;
        var queue = [];
        var label = "";
        var deQueue = function() {
            if (position < queue.length) {
                $timeout(function() {
                    queue[position](position);
                    //todo: doesn't work when 2 queues are launched
                    position++;
                    deQueue();
                });
            } else {
                that.reset();
            }
        };
        this.getPercent = function() {
            return position / queue.length * 100;
        };
        this.getLabel = function() {
            return label;
        };
        // this.initWorkerThread = function(jobs, label){
        //     for(jobIdx in Jobs){
        //         var blobURL = URL.createObjectURL(
        //             new Blob([ jobs[jobIdx] ], { type: 'application/javascript' })
        //             );
        //         var worker = new Worker(blobURL);
        //         queue.push(worker);
        //     }
        //     label = label;
        //     deQueue();
        // };
        this.init = function(jobs, label) {
            queue = queue.concat(jobs);
            label = label;
            deQueue();
        };
        this.reset = function() {
            queue = [];
            label = "";
            position = 0;
        };
    };
    this.Worker = function() {
        var URLDependencies = [];
        var functionDependencies = [];
        var moduleDependencies = [];
        var providerDependencies = [];
        var worker;
        var workerTemplate = [ "var window = self;", "self.history = {};", "self.Element = {prototype:{setAttribute:{}}};", "self.CSSStyleDeclaration = {prototype:{}};", "var document = {", "      documentElement:{matches:{}, style:{}},", "      readyState: 'complete',", "      cookie: '',", "      querySelector: function () {},", "      createElement: function () {", "          return {", "              pathname: '',", "              setAttribute: function () {}", "          };", "      }", "};", "<URL_DEPENDENCIES>", 'var workerApp = angular.module("WorkerApp", [<MODULE_DEPENDENCIES>]);', "workerApp.run(function (<PROVIDER_DEPENDENCIES>) {", "     <FUNCTION_DEPENDENCIES>", "     <WORKER_FUNCTION>", "})", 'angular.bootstrap(null, ["WorkerApp"]);' ];
        workerTemplate = workerTemplate.join("\n");
        var getBody = function(fct) {
            var text = fct.toString();
            return text.substring(text.indexOf("{") + 1, text.lastIndexOf("}"));
        };
        var addslashes = function(string) {
            return string.replace(/\\/g, "\\\\").replace(/\u0008/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/'/g, "\\'").replace(/"/g, '\\"');
        };
        this.dependencieToString = function(delegate) {
            if (typeof delegate == "object") {
                var result = "{";
                for (var attribute in delegate) {
                    result += this.dependencieToString(attribute) + ": " + this.dependencieToString(delegate[attribute]) + ",";
                }
                return result + "}";
            } else if (typeof delegate == "string") {
                return '"' + addslashes(delegate) + '"';
            } else {
                return delegate.toString();
            }
        };
        this.addAngularModule = function(module) {
            moduleDependencies.push(module);
        };
        this.addAngularProvider = function(provider) {
            providerDependencies.push(provider);
        };
        this.addDependencieFunction = function(name, delegate) {
            functionDependencies.push("var " + name + " = " + this.dependencieToString(delegate));
        };
        this.addDependencieURL = function(url) {
            URLDependencies.push(url);
        };
        this.getWorker = function(delegate) {
            var source = workerTemplate;
            source = source.replace("<URL_DEPENDENCIES>", "importScripts(" + URLDependencies.map(function(dep) {
                return "'" + dep + "'";
            }).join(",") + ")");
            source = source.replace("<MODULE_DEPENDENCIES>", moduleDependencies.map(function(dep) {
                return "'" + dep + "'";
            }).join(","));
            source = source.replace("<PROVIDER_DEPENDENCIES>", providerDependencies.join(","));
            source = source.replace("<FUNCTION_DEPENDENCIES>", functionDependencies.join("\n"));
            source = source.replace("<WORKER_FUNCTION>", getBody(delegate));
            worker = new Worker((window.URL ? URL : webkitURL).createObjectURL(new Blob([ source ], {
                type: "application/javascript"
            })));
            // handleTransactionsWorker.postMessage = handleTransactionsWorker.webkitPostMessage || handleTransactionsWorker.postMessage;
            return worker;
        };
    };
    return this;
} ]);

angular.module("utils").filter("replaceAll", function() {
    return function(str, find, replace) {
        return str.replace(new RegExp(find, "g"), replace);
    };
});

angular.module("utils").factory("saveFile", function() {
    //uses https://github.com/eligrey/FileSaver.js
    return function(name, content) {
        var blob = new Blob([ content ], {
            type: "text/plain"
        });
        saveAs(blob, name);
    };
});

angular.module("utils").directive("scrollToTopWhen", function() {
    return {
        restrict: "A",
        scope: {
            trigger: "=scrollToTopWhen"
        },
        link: function postLink(scope, elem) {
            scope.$watch("trigger", function() {
                elem[0].scrollTop = 0;
            });
        }
    };
});

angular.module("utils").filter("lastIndex", function() {
    return function(value, index) {
        for (var i = 4; i > 0; i--) {
            var result = value[index + i];
            if (result && result != "") return result;
        }
    };
});

angular.module("utils").filter("trustAsHtml", [ "$sce", function($sce) {
    return function(text) {
        return $sce.trustAsHtml(text);
    };
} ]);

angular.module("utils").filter("trustAsResourceUrl", [ "$sce", function($sce) {
    return function(val) {
        return $sce.trustAsResourceUrl(val);
    };
} ]);

angular.module("utils").factory("uniqueArrayService", function() {
    var uniqueArray = function() {
        this.elements = [];
    };
    uniqueArray.prototype = {
        Add: function(key, value) {
            if (!this.Contains(key)) {
                this.elements.push({
                    key: key,
                    value: value
                });
            }
        },
        Remove: function(key) {
            for (var i in this.elements) {
                if (this.elements[i].key == key) this.elements.splice(i, 1);
            }
        },
        Contains: function(key) {
            return this.GetByKey(key) ? true : false;
        },
        GetByKey: function(key) {
            for (var i in this.elements) {
                if (this.elements[i].key == key) return this.elements[i];
            }
        },
        GetByValue: function(value) {
            var result = this.elements.filter(function(d) {
                return d.value == value;
            });
            if (result.length > 0) return result;
        }
    };
    return uniqueArray;
});

angular.module("utils").factory("utilsService", function() {
    this.formatDate = function(d) {
        if (!d) return;
        var curr_date = d.getDate();
        var curr_month = d.getMonth() + 1;
        var curr_year = d.getFullYear();
        return curr_year + "-" + curr_month + "-" + curr_date;
    };
    this.formatDateHotel = function(d) {
        if (!d) return;
        var curr_date = d.getDate();
        var curr_month = d.getMonth() + 1;
        var curr_year = d.getFullYear();
        return curr_month + "/" + curr_date + "/" + curr_year;
    };
    this.getFormatedDate = function(dateStr) {
        if (!dateStr || dateStr == "NA") return;
        var a = dateStr.split(" ");
        var d = a[0].split("-");
        var t = a[1].split(":");
        //I choose to let the local time which as more meaning instead of the Greenwich mean time
        return new Date(d[0], d[1] - 1, d[2], t[0], t[1]);
    };
    // Filter an array to keep unique elements
    this.unique = function(array) {
        var o = {}, i, l = array.length, r = [];
        for (i = 0; i < l; i += 1) o[array[i]] = array[i];
        for (i in o) r.push(o[i]);
        return r;
    };
    return this;
});

angular.module("utils").directive("videoBg", [ "$http", function($http) {
    function link(scope, element, attrs) {}
    return {
        restrict: "E",
        templateUrl: "app/shared/utils/videoBg/videoBgTemplate.html",
        link: link
    };
} ]);

angular.module("Presentation").controller("RankingController", [ "$scope", "$filter", "dataAccessProvider", "legendProvider", "filterProvider", "dataFeaturesEnum", function($scope, $filter, dataAccessProvider, legendProvider, filterProvider, dataFeaturesEnum) {
    dataAccessProvider.csv("Ranking/dataClassement.csv", function(value) {
        //init model with data
        var data = legendProvider.parseData(value, dataFeaturesEnum);
        filterProvider.setData(data);
        // //Parameter model with values observed   
        // $scope.comparedFeaturesNames = ["network_operator_name", "network_group_name"];
        // $scope.rankedFeaturesNames = ["speed_download", "speed_upload"];
        // $scope.comparedFeatures = {};
        // $scope.rankedFeatures = {};
        // $scope.filter = {"network_operator_name": "noFilter", "network_group_name":"noFilter"};
        // $scope.data = {};
        // function getFeature(featureName){
        //     return dataFeaturesEnum[featureName];
        // }
        // function getLegend(featureName, data){
        //     var feature = getFeature(featureName);
        //     return new legendProvider.Feature(feature, legendProvider.getColumn(data, feature.name));
        // }
        // $scope.$watch("comparedFeaturesNames + rankedFeaturesNames",
        //     function(value){
        //         $scope.comparedFeatures = {};
        //         $scope.rankedFeatures = {};
        //         for(var featureIdx in $scope.rankedFeaturesNames)
        //             $scope.rankedFeatures[$scope.rankedFeaturesNames[featureIdx]] = getLegend($scope.rankedFeaturesNames[featureIdx], data);
        //         for(var featureIdx in $scope.comparedFeaturesNames){
        //             var legend = getLegend($scope.comparedFeaturesNames[featureIdx], data);
        //             $scope.comparedFeatures[$scope.comparedFeaturesNames[featureIdx]] = legend;
        //             var values = legend.getDistinctValues();
        //             for(var valueIdx in values){
        //                 var filter = {};
        //                 filter[legend.name] = valueIdx;
        //                 var score = getLegend($scope.rankedFeaturesNames[0], getFilteredData(filter)).getAverage();
        //                 values[valueIdx]["score"] = score
        //             }
        //         }
        //     })
        // $scope.filterExpression = function(d){
        //     // data in kbps
        //     d = d/(1024*8);
        //     return $filter("number")(d, 2);
        // };
        // function getFilteredData(filter){
        //     var filterCondition = [];
        //     for(filterIdx in filter){
        //         if(filter[filterIdx] !== "noFilter")
        //             filterCondition.push({feature:$scope.comparedFeatures[filterIdx], value: filter[filterIdx]});
        //     }
        //     filterProvider.setConditions(filterCondition);
        //     return filterProvider.getResult();
        // }
        // //compute the result to display
        // $scope.$watch("filter",
        //     function(value){
        //         console.log(value)
        //         var filteredData = getFilteredData($scope.filter);
        //         $scope.data = {};
        //         for(var featureIdx in $scope.rankedFeatures){
        //             var allLegend = $scope.rankedFeatures[featureIdx];
        //             var filteredLegend =  new legendProvider.Feature(allLegend, legendProvider.getColumn(filteredData, allLegend.name));
        //             filteredLegend.getDistinctValuesArray().forEach(function(filteredValue, idx){
        //                 filteredValue.color = allLegend.getDistinctValues()[filteredValue.value].color;
        //             })
        //             $scope.data[featureIdx] = filteredLegend;
        //         }
        //     }, true)
        $scope.axes = {};
        $scope.axes.xAxis = dataFeaturesEnum["network_operator_name"];
        $scope.axes.yAxis = dataFeaturesEnum["speed_download"];
        $scope.axes.zAxis = dataFeaturesEnum["network_group_name"];
        $scope.$watch("axes.zAxis", function() {
            $scope.zAxisLegend = new legendProvider.Feature($scope.axes.zAxis, legendProvider.getColumn(data, $scope.axes.zAxis.name));
            $scope.axes.zAxisFilter = "noFilter";
        });
        $scope.features = {};
        $scope.features.xAxis = [ dataFeaturesEnum["network_operator_name"] ];
        $scope.features.yAxis = [ dataFeaturesEnum["speed_download"], dataFeaturesEnum["speed_upload"] ];
        $scope.features.zAxis = [ dataFeaturesEnum["network_group_name"], dataFeaturesEnum["network_type.name"] ];
        function KbToMB(d) {
            // data in kbps
            d = d / (1024 * 8);
            return d;
        }
        $scope.data = {};
        $scope.$watch(function() {
            return {
                xAxis: $scope.axes.xAxis,
                yAxis: $scope.axes.yAxis,
                zAxisFilter: $scope.axes.zAxisFilter
            };
        }, function() {
            var zCondition = {};
            if ($scope.axes.zAxisFilter !== "noFilter") zCondition = {
                feature: $scope.axes.zAxis,
                value: $scope.axes.zAxisFilter
            };
            var xLegend = new legendProvider.Feature($scope.axes.xAxis, legendProvider.getColumn(data, $scope.axes.xAxis.name));
            var xValues = xLegend.getDistinctValues();
            for (var xValue in xValues) {
                var xCondition = {
                    feature: $scope.axes.xAxis,
                    value: xValue
                };
                filterProvider.setConditions([ zCondition, xCondition ]);
                var filteredData = filterProvider.getResult();
                var score = new legendProvider.Feature($scope.axes.yAxis, legendProvider.getColumn(filteredData, $scope.axes.yAxis.name)).getAverage();
                xValues[xValue].score = KbToMB(score);
            }
            xLegend.getDistinctValuesArray().sort(function(a, b) {
                if (!a.score) a.score = 0;
                if (!b.score) b.score = 0;
                return a.score - b.score;
            });
            $scope.data = xLegend;
        }, true);
    }, function(error) {
        window.alert("couldn't load data : status \"" + error.statusText + '"');
    });
} ]);

angular.module("Presentation").controller("RankingControllerTest", [ "$scope", "$filter", "dataAccessProvider", "legendProvider", "filterProvider", "dataFeaturesEnum", function($scope, $filter, dataAccessProvider, legendProvider, filterProvider, dataFeaturesEnum) {
    dataAccessProvider.csv("Ranking/dataClassement.csv", function(value) {
        //init model with data
        var data = legendProvider.parseData(value, dataFeaturesEnum);
        filterProvider.setData(data);
        //Parameter model with values observed   
        $scope.comparedFeaturesNames = [ "network_operator_name", "network_group_name" ];
        $scope.rankedFeaturesNames = [ "speed_download", "speed_upload" ];
        $scope.comparedFeatures = {};
        $scope.rankedFeatures = {};
        $scope.filter = {
            network_operator_name: "noFilter",
            network_group_name: "noFilter"
        };
        $scope.data = {};
        function getFeature(featureName) {
            return dataFeaturesEnum[featureName];
        }
        function getLegend(featureName, data) {
            var feature = getFeature(featureName);
            return new legendProvider.Feature(feature, legendProvider.getColumn(data, feature.name));
        }
        $scope.$watch("comparedFeaturesNames + rankedFeaturesNames", function(value) {
            $scope.comparedFeatures = {};
            $scope.rankedFeatures = {};
            for (var featureIdx in $scope.rankedFeaturesNames) $scope.rankedFeatures[$scope.rankedFeaturesNames[featureIdx]] = getLegend($scope.rankedFeaturesNames[featureIdx], data);
            for (var featureIdx in $scope.comparedFeaturesNames) {
                var legend = getLegend($scope.comparedFeaturesNames[featureIdx], data);
                $scope.comparedFeatures[$scope.comparedFeaturesNames[featureIdx]] = legend;
                var values = legend.getDistinctValues();
                for (var valueIdx in values) {
                    var filter = {};
                    filter[legend.name] = valueIdx;
                    var score = getLegend($scope.rankedFeaturesNames[0], getFilteredData(filter)).getAverage();
                    values[valueIdx]["score"] = score;
                }
            }
        });
        $scope.filterExpression = function(d) {
            // data in kbps
            d = d / (1024 * 8);
            return $filter("number")(d, 2);
        };
        function getFilteredData(filter) {
            var filterCondition = [];
            for (filterIdx in filter) {
                if (filter[filterIdx] !== "noFilter") filterCondition.push({
                    feature: $scope.comparedFeatures[filterIdx],
                    value: filter[filterIdx]
                });
            }
            filterProvider.setConditions(filterCondition);
            return filterProvider.getResult();
        }
        //compute the result to display
        $scope.$watch("filter", function(value) {
            console.log(value);
            var filteredData = getFilteredData($scope.filter);
            $scope.data = {};
            for (var featureIdx in $scope.rankedFeatures) {
                var allLegend = $scope.rankedFeatures[featureIdx];
                var filteredLegend = new legendProvider.Feature(allLegend, legendProvider.getColumn(filteredData, allLegend.name));
                filteredLegend.getDistinctValuesArray().forEach(function(filteredValue, idx) {
                    filteredValue.color = allLegend.getDistinctValues()[filteredValue.value].color;
                });
                $scope.data[featureIdx] = filteredLegend;
            }
        }, true);
    }, function(error) {
        window.alert("couldn't load data : status \"" + error.statusText + '"');
    });
} ]);

angular.module("Presentation").controller("RhoUncertaintyController", [ "$scope", "$sce", "dataAccessProvider", function($scope, $sce, dataAccessProvider) {
    $scope.D = null;
    $scope.DPrime = null;
    dataAccessProvider.csv("RhoUncertainty/transactions.csv", //"data/POQEMON/dataCompressed.csv",
    function(value) {
        $scope.D = value;
    }, function(error) {
        window.alert("couldn't load data : status \"" + error.statusText + '"');
    });
    dataAccessProvider.csv("RhoUncertainty/transactionsSupp.csv", //"data/POQEMON/dataCompressed.csv",
    function(value) {
        $scope.DSupp = value;
    }, function(error) {
        window.alert("couldn't load data : status \"" + error.statusText + '"');
    });
    dataAccessProvider.csv("RhoUncertainty/result05.csv", //"data/POQEMON/dataCompressed.csv",
    function(value) {
        $scope.DPrime = value;
    }, function(error) {
        window.alert("couldn't load data : status \"" + error.statusText + '"');
    });
    d3.json("RhoUncertainty/hierarchy.json", function(json) {
        console.log(json);
        var getTuple = function(string) {
            var re = /(u?'(.+)', u?'(.+)')/;
            var match = string.match(re);
            if (match) return {
                feature: match[2],
                value: match[3]
            }; else return {
                feature: "",
                value: string
            };
        };
        var getChildren = function(node, depth, maxDepth) {
            var result = [ node ];
            if (depth <= maxDepth) {
                for (var i in node.children) result = result.concat(getChildren(node.children[i], depth + 1, maxDepth));
            }
            return result;
        };
        getNode = function(dict, node) {
            if (!dict[node]) dict[node] = {
                name: node,
                children: [],
                parent: []
            };
            return dict[node];
        };
        addLink = function(dict, source, target) {
            source = getNode(dict, source);
            target = getNode(dict, target);
            source.children.push(target);
            target.parent.push(source);
        };
        $scope.$apply(function() {
            featureColor = {};
            $scope.nodes = [];
            $scope.links = [];
            dictTmp = {};
            for (var source in json) {
                for (var targetIdx in json[source]) {
                    var target = json[source][targetIdx];
                    addLink(dictTmp, source, target);
                }
            }
            for (var nodeIdx in dictTmp) {
                var node = dictTmp[nodeIdx];
                $scope.nodes.push(node);
                for (targetIdx in node.children) {
                    var target = node.children[targetIdx];
                    $scope.links.push({
                        source: node,
                        target: target
                    });
                }
            }
            $scope.hovered = null;
            $scope.$watch("hovered", function(hovered, oldHovered) {
                if (oldHovered) {
                    var children = getChildren(oldHovered, 0, 100);
                    for (var child in children) children[child]["hovered"] = false;
                }
                if (hovered) {
                    var children = getChildren(hovered, 0, 100);
                    for (var child in children) children[child]["hovered"] = true;
                }
            });
            $scope.nodeOpacityDlg = function(d) {
                if ($scope.hovered) {
                    if (d["hovered"]) return 1;
                    return .5;
                }
                return 1;
            };
            $scope.linkOpacityDlg = function(d) {
                if ($scope.hovered) {
                    if (d.source["hovered"]) return 1;
                    return .5;
                }
                return .75;
            };
            $scope.textDlg = function(d) {
                var text = getTuple(d.name).value;
                if (text.match(/http:\/\/dbpedia.org\/resource\//)) return "DB:" + text.substring(28); else return text;
            };
            $scope.fillDlg = function(d) {
                var feature = getTuple(d.name).feature;
                if (!featureColor[feature]) featureColor[feature] = Object.keys(featureColor).length + 1;
                return featureColor[feature];
            };
            $scope.radiusDlg = function(d) {
                return getChildren(d, 0, 100).length;
            };
        });
    });
    $scope.$watch("D + DPrime + nodes + DSupp", function() {
        $scope.storyline = [ {
            title: $sce.trustAsHtml("Rho-uncertainty"),
            header: $sce.trustAsHtml("<a href='http://karras.rutgers.edu/p-uncertainty.pdf' >&#961;-uncertainty</a> is a privacy concept that safeguards against sensitive associations without falsifying data. This problem is solved by a technique which combines generalization and suppression. We will demonstrate this technique in this interactive example."),
            footer: $sce.trustAsHtml("You can press next when you are done.")
        }, {
            title: $sce.trustAsHtml("Utility of the data"),
            header: $sce.trustAsHtml("Lets consider a dataset consisting of records crowdsourced in our application. Such data are then used in data mining applications, such as association rule mining, to discover trends in the data. Here is one example consisting of 8 records and 6 attributes that we want to analyse."),
            D: $scope.D,
            footer: $sce.trustAsHtml('From those data, we can infer trends. For exemple, if you are in possession of an "iPhone-6" you are more likely to use a "4G" connection than "Nexus-4" users.')
        }, {
            title: $sce.trustAsHtml("Threat"),
            D: $scope.D,
            footer: $sce.trustAsHtml('However, the publication of such data poses privacy threats. A particular threat is posed by an adversary who has <em>partial</em> knowledge of a certain user\'s record, and may use it to identify previously unknown sensitive informations about this user. For exemple, if I know someone who did the test with an "iPhone-6" using the operator "Orange", I can infer from the data published that he was in Paris on the "30/09/2015". So, from the initial knowledge that my friend was in this database and some basic informations, I was able to identify his location.')
        }, {
            title: $sce.trustAsHtml("Sensitives associoation rule"),
            header: $sce.trustAsHtml("The inference of a sensitive value by a previous knowledge is formulated by an association rule. We then can compute the confidence of this rule, which is the probability of finding the sensitive value if the initial knowledge is present."),
            SRi: [ {
                antecedent: [ "iPhone-6", "Orange" ],
                consequent: [ "Paris" ],
                confidence: 1
            }, {
                antecedent: [ "iPhone-6", "4G" ],
                consequent: [ "Paris" ],
                confidence: "1/3"
            } ],
            footer: $sce.trustAsHtml("Our goal is to remove all rules which have a high confidence, and thus could be used by an attacker. The confidence thresold is called &#961;.")
        }, {
            title: $sce.trustAsHtml("Simple suppression"),
            header: $sce.trustAsHtml("A trivial solution to prevent such threats would be to determine each sensitive attributes, such as the position of the user, and to suppress them. But this solution sacrifice a lot of informations. With &#961;-uncertainty, we want to keep the most utility of our data. "),
            D: $scope.DSupp,
            footer: $sce.trustAsHtml("To do so, we will use both a <em>suppression method</em> and a <em>generalisation method</em>.")
        }, {
            title: $sce.trustAsHtml("Suppress method"),
            header: $sce.trustAsHtml("The suppression method will look for each sensitives rules in the data, and find the values wich can be suppressed to conceal them. This heuristic is called the <em>payoff ratio</em>. This ratio expresses the amount of sensitive association rules concealed per unit of lost information, which is the support of the value supressed."),
            SRi: [ {
                antecedent: [ "Lumia-640 (supp 1)" ],
                consequent: [ "Nancy" ],
                confidence: 1
            } ]
        }, {
            title: $sce.trustAsHtml("Generalisation Method"),
            header: $sce.trustAsHtml("The generalisation method uses a hierarchy to generalise values to one of the node of the hierarchy. Thus, some sensitives association rules will disapear as the values wich could be used to infer sensitive information are no longer distinguished in the data. the hierarchy used in this example is here :"),
            H: {
                nodes: $scope.nodes,
                links: $scope.links
            },
            footer: $sce.trustAsHtml("The generalisation method uses an heuristic called the <em>Information Loss</em> to determine wich level of the hierarchy to use. This heuristic takes into account the amount of values obfuscated by the generalisation and the amount of values wich should have been suppressed without generalisation to keep the dataset anonymized.")
        }, {
            title: $sce.trustAsHtml("Result"),
            header: $sce.trustAsHtml("The resulting dataset, after generalisation and suppression, is then computed :"),
            D: $scope.DPrime,
            footer: $sce.trustAsHtml('this demonstrate the use of suppression Method, with the value "Luna-640" which infered the value "Nancy", and the generalisation of the attributes "Operator", "Time", "Device" and "Speed".')
        } ];
    });
} ]);

angular.module("Presentation").controller("VisualisationController", [ "$scope", "$http", "$timeout", "dataAccessProvider", "legendProvider", "filterProvider", "dataFeaturesEnum", function($scope, $http, $timeout, dataAccessProvider, legendProvider, filterProvider, dataFeaturesEnum) {
    //scope
    $scope.raw = [];
    $scope.filtered = [];
    $scope.data = {
        legend: [],
        filtered: [],
        features: Object.keys(dataFeaturesEnum).map(function(key) {
            return dataFeaturesEnum[key];
        })
    };
    $scope.legendized = {};
    var baseLegend = {};
    function getBaseLegend(featureIdx) {
        if (!baseLegend[featureIdx]) {
            var feature = dataFeaturesEnum[featureIdx];
            baseLegend[feature.name] = new legendProvider.Feature(feature, legendProvider.getColumn($scope.raw, feature.name));
        }
        return baseLegend[featureIdx];
    }
    function getFilteredLegend(featureIdx) {
        var feature = dataFeaturesEnum[featureIdx];
        var filteredLegend = new legendProvider.Feature(feature, legendProvider.getColumn($scope.filtered, feature.name));
        filteredLegend.getDistinctValuesArray().forEach(function(filteredValue, idx) {
            filteredValue.color = getBaseLegend(feature.name).getDistinctValues()[filteredValue.value].color;
        });
        return filteredLegend;
    }
    //scope.data behavior
    dataAccessProvider.csv("Visualisation/demo.csv", //"data/POQEMON/dataCompressed.csv",
    function(value) {
        $scope.raw = legendProvider.parseData(value, dataFeaturesEnum);
    }, function(error) {
        window.alert("couldn't load data : status \"" + error.statusText + '"');
    });
    $scope.$watch("raw", function(value) {
        if (!value.length) return;
        filterProvider.setData(value);
        filterProvider.setConditions([]);
        $scope.filtered = filterProvider.getResult();
        $scope.addChart("speed_download");
        $scope.selectChart("speed_download");
    });
    $scope.$watch("filtered", function(value) {
        for (var featureIdx in $scope.legendized) {
            $scope.legendized[featureIdx] = getFilteredLegend(featureIdx);
        }
    });
    $scope.$watch("featuresNames", function(value) {
        if (value) {
            for (var feature in value) $scope.addChart(value[feature].id);
        }
    });
    $scope.$watch("selected", function(value) {
        if (value) $scope.addChart(value);
    });
    $scope.addChart = function(featureIdx) {
        $scope.legendized[featureIdx] = getFilteredLegend(featureIdx);
    };
    $scope.removeChart = function(featureIdx) {
        delete $scope.legendized[featureIdx];
    };
    $scope.selectChart = function(featureIdx) {
        $scope.selected = featureIdx;
    };
    $scope.openGraphFormModal = function(urlTemplate) {
        var modal = $scope.openModal(urlTemplate, $scope, function(result) {
            $scope.addChart(result.name);
        });
        modal.opened.then(function() {});
    };
    var Where = function(feature) {
        this.feature = feature;
        /**
             * @ngdoc property
             * @name home.controllers.FormController.Where:value
             * @description The value used to filter
             */
        this.value = null;
        this.minValue = null;
        this.maxValue = null;
        this.timeout = 1e3;
        var _play = false;
        this.indexValue = null;
    };
    $scope.where = [];
    //scope.form behavior
    $scope.addWhere = function(feature, where) {
        var whereNewRef = new Where();
        if (where) {
            for (var i in where) whereNewRef[i] = where[i];
        }
        if (feature) whereNewRef.feature = feature; else whereNewRef.feature = form.select;
        $scope.where.push(whereNewRef);
    };
    $scope.removeWhere = function(index) {
        if (index == -1) $scope.where = []; else $scope.where.splice(index, 1);
    };
    //we watch the "where" conditions to filter the data and create a new legend.
    //because the Feature objects are really big, we have to obsere only some fields
    //and only call the callback when there are effectives changes in the conditions
    $scope.$watch(function() {
        var impactingValues = [];
        $scope.where.forEach(function(value) {
            if (value.minValue !== undefined && value.minValue !== null || value.maxValue !== undefined && value.maxValue !== null || value.value !== undefined && value.value !== null) impactingValues.push({
                value: value.value,
                minValue: value.minValue,
                maxValue: value.maxValue
            });
        });
        return impactingValues;
    }, function(newVal, oldVal) {
        var startTime = new Date();
        if (newVal == oldVal) return;
        filterProvider.setConditions($scope.where);
        $scope.filtered = filterProvider.getResult();
        console.log("filter : " + (new Date() - startTime));
    }, true);
} ]);